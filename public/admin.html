<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noema Admin</title>
  <style>
    :root {
      color-scheme: dark;
      --bg-0: #061020;
      --bg-1: #10243b;
      --bg-2: #1a2f44;
      --text: #ebf3ff;
      --muted: #9ab1ce;
      --panel: rgba(12, 21, 40, .74);
      --panel-soft: rgba(14, 28, 46, .54);
      --border: rgba(145, 183, 227, .3);
      --accent: #78aebf;
      --danger: #d08a9a;
      --ok: #7ec8b8;
      --warn: #f0bd7a;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 8% 8%, rgba(120, 174, 191, .18), transparent 42%),
        radial-gradient(circle at 92% 10%, rgba(255, 154, 95, .14), transparent 36%),
        radial-gradient(circle at 78% 82%, rgba(112, 183, 255, .16), transparent 40%),
        linear-gradient(158deg, var(--bg-0) 0%, var(--bg-1) 50%, var(--bg-2) 100%);
      padding: 14px;
      overflow: hidden;
    }

    .workspace {
      height: calc(100vh - 28px);
      max-width: 1800px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 360px minmax(0, 1fr);
      gap: 12px;
    }

    .glass-strong {
      border: 1px solid var(--border);
      border-radius: 24px;
      background: var(--panel);
      backdrop-filter: blur(22px) saturate(145%);
      -webkit-backdrop-filter: blur(22px) saturate(145%);
      box-shadow: 0 32px 72px rgba(3, 9, 22, .52), inset 0 1px 0 rgba(170, 210, 255, .18);
    }

    .glass-soft {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel-soft);
      backdrop-filter: blur(16px) saturate(135%);
      -webkit-backdrop-filter: blur(16px) saturate(135%);
    }

    .sidebar {
      min-height: 0;
      display: grid;
      grid-template-rows: auto auto auto minmax(0, 1fr) auto;
      gap: 10px;
      padding: 12px;
    }

    .brand-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 2px 2px 4px;
    }

    .brand {
      color: var(--text);
      text-decoration: none;
      font-size: 28px;
      line-height: 1;
      letter-spacing: .02em;
      font-weight: 700;
      font-family: "Avenir Next", "SF Pro Display", "Segoe UI", sans-serif;
    }

    .badge {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: var(--muted);
      background: rgba(16, 33, 52, .52);
    }

    .toolbar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .status-line {
      font-size: 12px;
      color: var(--muted);
      min-height: 1.4em;
      padding: 0 2px;
    }

    .status-line[data-kind="success"] { color: var(--ok); }
    .status-line[data-kind="error"] { color: #ffb7c3; }
    .status-line[data-kind="warn"] { color: var(--warn); }

    .catalog {
      min-height: 0;
      overflow: auto;
      padding-right: 2px;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .chapter-card {
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .chapter-head {
      display: grid;
      grid-template-columns: auto auto minmax(0, 1fr);
      gap: 8px;
      align-items: center;
    }

    .chapter-drop {
      min-height: 56px;
      border: 1px dashed rgba(145, 183, 227, .45);
      border-radius: 12px;
      padding: 8px;
      display: grid;
      gap: 8px;
      background: rgba(9, 18, 31, .24);
    }

    .chapter-drop.is-over,
    .chapter-head.is-over,
    .notebook-row.is-over {
      border-color: color-mix(in oklab, var(--accent) 70%, white);
      box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 32%, transparent);
      background: rgba(21, 47, 72, .32);
    }

    .empty-drop {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding: 8px 4px;
    }

    .notebook-row {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px;
      background: rgba(16, 31, 50, .72);
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      gap: 6px;
      align-items: center;
    }

    .notebook-row.active {
      border-color: color-mix(in oklab, var(--accent) 72%, white);
      background: rgba(19, 42, 64, .76);
    }

    .drag-handle {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(17, 34, 54, .5);
      color: var(--muted);
      padding: 5px 7px;
      cursor: grab;
      line-height: 1;
      font-size: 12px;
      user-select: none;
    }

    .drag-handle:active { cursor: grabbing; }

    .caret {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(17, 34, 54, .5);
      color: var(--text);
      width: 30px;
      height: 30px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 12px;
    }

    .editor-card {
      min-height: 0;
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr) auto;
      overflow: hidden;
    }

    .editor-header {
      border-bottom: 1px solid var(--border);
      padding: 10px 14px;
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      align-items: center;
      gap: 10px;
      background: rgba(12, 21, 40, .84);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .back {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(17, 34, 54, .52);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      font-size: 18px;
      line-height: 1;
    }

    .editor-title {
      margin: 0;
      text-align: center;
      font-size: 21px;
      letter-spacing: .01em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .editor-meta {
      border-bottom: 1px solid var(--border);
      padding: 8px 14px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .editor-main {
      min-height: 0;
      overflow: auto;
      padding: 12px;
      display: grid;
      grid-template-columns: 320px minmax(0, 1fr);
      gap: 12px;
    }

    .meta-panel {
      padding: 10px;
      display: grid;
      gap: 8px;
      align-content: start;
      max-height: 100%;
      overflow: auto;
    }

    .meta-section-title {
      margin: 0;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .02em;
    }

    .editor-panel {
      min-height: 0;
      display: grid;
      grid-template-rows: minmax(0, 1fr) auto;
      gap: 10px;
    }

    .ipynb-editor {
      width: 100%;
      height: 100%;
      min-height: 68vh;
      border: 1px solid var(--border);
      background: rgba(10, 22, 38, .78);
      color: var(--text);
      border-radius: 14px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
      font-size: 12px;
      line-height: 1.62;
      resize: none;
      outline: none;
    }

    .ipynb-editor:focus,
    .field:focus,
    .field-textarea:focus {
      border-color: color-mix(in oklab, var(--accent) 70%, white);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 24%, transparent);
    }

    .field,
    .field-textarea,
    .chapter-input,
    .notebook-input,
    .upload-input,
    .upload-select {
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(16, 32, 52, .62);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
    }

    .field-textarea {
      min-height: 80px;
      resize: vertical;
      font-family: inherit;
    }

    .patch-panel {
      margin-top: 6px;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .patch-textarea {
      min-height: 90px;
      resize: vertical;
      font-family: inherit;
    }

    .patch-actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
    }

    .patch-summary {
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
      line-height: 1.5;
    }

    .patch-diff-panel {
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .patch-diff-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .patch-diff {
      margin: 0;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(7, 15, 28, .74);
      color: var(--text);
      font-size: 12px;
      line-height: 1.55;
      max-height: 34vh;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    }

    .chapter-input,
    .notebook-input {
      padding: 6px 8px;
      font-size: 12px;
    }

    .upload-panel {
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .upload-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .upload-form {
      display: grid;
      gap: 8px;
    }

    .upload-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .button,
    .button-ghost,
    .button-danger {
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
      text-decoration: none;
      white-space: nowrap;
      border: 1px solid transparent;
      color: var(--text);
      background: transparent;
    }

    .button {
      border-color: color-mix(in oklab, var(--accent) 52%, white);
      color: color-mix(in oklab, #f7fbff 88%, var(--text));
      background: linear-gradient(
        145deg,
        color-mix(in oklab, #71aabd 58%, rgba(12, 21, 40, .74)) 0%,
        color-mix(in oklab, #5b8ea2 62%, rgba(12, 23, 43, .36)) 100%
      );
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      box-shadow: 0 10px 22px color-mix(in oklab, var(--accent) 18%, transparent), inset 0 1px 0 rgba(255,255,255,.26);
    }

    .button-ghost {
      border-color: var(--border);
      background: rgba(17, 34, 54, .5);
    }

    .button-danger {
      border-color: color-mix(in oklab, var(--danger) 52%, white);
      color: #fff3f6;
      background: linear-gradient(
        145deg,
        color-mix(in oklab, var(--danger) 46%, transparent),
        color-mix(in oklab, var(--danger) 28%, #2c1b24)
      );
    }

    .button:disabled,
    .button-ghost:disabled,
    .button-danger:disabled,
    .drag-handle:disabled,
    .caret:disabled {
      opacity: .55;
      cursor: not-allowed;
    }

    .footer-row {
      display: flex;
      gap: 8px;
    }

    .footer-row > * { flex: 1; }

    .bottom-status {
      border-top: 1px solid var(--border);
      padding: 8px 14px;
      min-height: 40px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    @media (max-width: 1260px) {
      body {
        overflow: auto;
      }

      .workspace {
        height: auto;
        min-height: calc(100vh - 28px);
        grid-template-columns: 1fr;
      }

      .editor-main {
        grid-template-columns: 1fr;
      }

      .ipynb-editor {
        min-height: 56vh;
      }
    }

    @media (max-width: 720px) {
      .upload-row {
        grid-template-columns: 1fr;
      }

      .editor-header {
        grid-template-columns: 1fr;
      }

      .editor-title {
        text-align: left;
      }

      .header-actions {
        justify-content: flex-start;
        flex-wrap: wrap;
      }

      .patch-actions {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="workspace">
    <aside class="sidebar glass-strong">
      <div class="brand-row">
        <a class="brand" href="/" id="brand-link">Noema</a>
        <span class="badge" id="count-label">0 sections / 0 notebooks</span>
      </div>

      <div class="toolbar">
        <button class="button" id="add-section-btn" type="button">+ セクション</button>
        <button class="button-ghost" id="reload-catalog-btn" type="button">再読込</button>
      </div>

      <div class="status-line" id="structure-status" data-kind="info">構成の自動保存: 有効</div>

      <div class="catalog" id="catalog"></div>

      <section class="upload-panel glass-soft">
        <div class="upload-head">
          <strong>教材を追加</strong>
          <span class="badge">ipynb</span>
        </div>
        <form class="upload-form" id="upload-form">
          <label class="sr-only" for="upload-title">タイトル</label>
          <input class="upload-input" id="upload-title" name="title" placeholder="タイトル" required />

          <div class="upload-row">
            <select class="upload-select" id="upload-section-select" name="sectionSelect"></select>
            <input class="upload-input" id="upload-new-section" name="newSection" placeholder="新規セクション名（任意）" />
          </div>

          <div class="upload-row">
            <input class="upload-input" name="tags" placeholder="タグ (comma separated)" />
            <input class="upload-input" name="colabUrl" placeholder="Colab URL" value="https://colab.research.google.com/" required />
          </div>

          <input class="upload-input" name="videoUrl" placeholder="Video URL (optional)" />
          <input class="upload-input" name="file" type="file" accept=".ipynb,application/json" required />
          <button class="button" id="upload-btn" type="submit">ipynbを登録</button>
        </form>
        <div class="status-line" id="upload-status" data-kind="info"></div>
      </section>

      <div class="footer-row">
        <a class="button-ghost" href="/">学習トップ</a>
        <button class="button-ghost" id="logout-btn" type="button">ログアウト</button>
      </div>
    </aside>

    <section class="editor-card glass-strong">
      <header class="editor-header">
        <a class="back" href="/" aria-label="トップへ戻る">‹</a>
        <h1 class="editor-title" id="editor-title">ノート未選択</h1>
        <div class="header-actions">
          <button class="button" id="manual-save-btn" type="button">保存</button>
          <button class="button-ghost" id="reload-notebook-btn" type="button">再読込</button>
        </div>
      </header>

      <div class="editor-meta">
        <span id="editor-meta">ノートを選択してください。</span>
        <span id="editor-save-state">自動保存: 待機中</span>
      </div>

      <div class="editor-main">
        <section class="meta-panel glass-soft">
          <h2 class="meta-section-title">ノート設定</h2>
          <label>
            <div class="status-line">Notebook ID</div>
            <input class="field" id="meta-notebook-id" readonly />
          </label>

          <label>
            <div class="status-line">タイトル</div>
            <input class="field" id="meta-title" />
          </label>

          <label>
            <div class="status-line">セクション</div>
            <input class="field" id="meta-chapter" readonly />
          </label>

          <label>
            <div class="status-line">タグ (comma separated)</div>
            <input class="field" id="meta-tags" />
          </label>

          <label>
            <div class="status-line">Colab URL</div>
            <input class="field" id="meta-colab" />
          </label>

          <label>
            <div class="status-line">Video URL (optional)</div>
            <input class="field" id="meta-video" />
          </label>

          <section class="patch-panel glass-soft">
            <h2 class="meta-section-title">LLMパッチ提案</h2>
            <textarea
              class="field-textarea patch-textarea"
              id="patch-instruction"
              placeholder="例: 2章の導入説明を初学者向けに具体例つきで改善し、数式説明を補強する"
            ></textarea>
            <div class="patch-actions">
              <button class="button" id="patch-generate-btn" type="button">提案生成</button>
              <button class="button" id="patch-apply-btn" type="button" disabled>採用</button>
              <button class="button-ghost" id="patch-reject-btn" type="button" disabled>却下</button>
            </div>
            <div class="status-line" id="patch-status" data-kind="info"></div>
            <div class="patch-summary" id="patch-summary"></div>
          </section>
        </section>

        <section class="editor-panel">
          <textarea class="ipynb-editor" id="ipynb-editor" spellcheck="false" placeholder="ここに ipynb JSON が表示されます"></textarea>
          <section class="patch-diff-panel glass-soft" id="patch-diff-panel" hidden>
            <div class="patch-diff-head">
              <strong>提案差分 (unified diff)</strong>
              <span id="patch-model-label"></span>
            </div>
            <pre class="patch-diff" id="patch-diff"></pre>
          </section>
        </section>
      </div>

      <div class="bottom-status" id="editor-status">準備完了</div>
    </section>
  </main>

  <script>
    (function () {
      const API_BASE = "https://52d3l83li2.execute-api.ap-northeast-3.amazonaws.com";
      const TOKEN_KEY = "noema_id_token";

      const el = {
        catalog: document.getElementById("catalog"),
        countLabel: document.getElementById("count-label"),
        structureStatus: document.getElementById("structure-status"),
        addSectionBtn: document.getElementById("add-section-btn"),
        reloadCatalogBtn: document.getElementById("reload-catalog-btn"),
        uploadForm: document.getElementById("upload-form"),
        uploadBtn: document.getElementById("upload-btn"),
        uploadStatus: document.getElementById("upload-status"),
        uploadSectionSelect: document.getElementById("upload-section-select"),
        uploadNewSection: document.getElementById("upload-new-section"),
        logoutBtn: document.getElementById("logout-btn"),
        editorTitle: document.getElementById("editor-title"),
        editorMeta: document.getElementById("editor-meta"),
        editorSaveState: document.getElementById("editor-save-state"),
        editorStatus: document.getElementById("editor-status"),
        manualSaveBtn: document.getElementById("manual-save-btn"),
        reloadNotebookBtn: document.getElementById("reload-notebook-btn"),
        ipynbEditor: document.getElementById("ipynb-editor"),
        metaNotebookId: document.getElementById("meta-notebook-id"),
        metaTitle: document.getElementById("meta-title"),
        metaChapter: document.getElementById("meta-chapter"),
        metaTags: document.getElementById("meta-tags"),
        metaColab: document.getElementById("meta-colab"),
        metaVideo: document.getElementById("meta-video"),
        patchInstruction: document.getElementById("patch-instruction"),
        patchGenerateBtn: document.getElementById("patch-generate-btn"),
        patchApplyBtn: document.getElementById("patch-apply-btn"),
        patchRejectBtn: document.getElementById("patch-reject-btn"),
        patchStatus: document.getElementById("patch-status"),
        patchSummary: document.getElementById("patch-summary"),
        patchDiffPanel: document.getElementById("patch-diff-panel"),
        patchDiff: document.getElementById("patch-diff"),
        patchModelLabel: document.getElementById("patch-model-label")
      };

      const state = {
        chapters: [],
        openMap: {},
        activeNotebookId: "",
        ipynbRaw: "",
        ipynbSavedRaw: "",
        structureSaveTimer: 0,
        notebookSaveTimer: 0,
        dragPayload: null,
        structureDirty: false,
        notebookDirty: false,
        savedStructureHash: "",
        loadSeq: 0,
        savingStructure: false,
        savingNotebook: false,
        patchGenerating: false,
        patchProposal: null
      };

      function escapeHtml(value) {
        return String(value ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function uid(prefix) {
        return `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      }

      function parseJwt(token) {
        try {
          const payload = token.split(".")[1];
          return JSON.parse(atob(payload.replace(/-/g, "+").replace(/_/g, "/")));
        } catch {
          return null;
        }
      }

      function getToken() {
        const token = localStorage.getItem(TOKEN_KEY) || "";
        if (!token) return "";
        const payload = parseJwt(token);
        if (!payload) return "";
        if (payload.exp && Date.now() >= payload.exp * 1000) {
          localStorage.removeItem(TOKEN_KEY);
          return "";
        }
        return token;
      }

      function requireLogin() {
        const token = getToken();
        if (token) return token;
        window.location.href = "/login";
        throw new Error("ログインが必要です。");
      }

      async function api(path, init) {
        const token = requireLogin();
        let response;
        try {
          response = await fetch(`${API_BASE}${path}`, {
            ...init,
            headers: {
              ...(init && init.headers ? init.headers : {}),
              Authorization: `Bearer ${token}`
            }
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if (/load failed|failed to fetch/i.test(message)) {
            throw new Error(
              "API通信がブラウザで遮断されました。API Gatewayのルート不足(GET /api/admin/notebooks 等)かCORS不整合の可能性があります。Deploy Infraを最新コミットで再実行してください。"
            );
          }
          throw new Error(`APIに接続できませんでした: ${message}`);
        }

        let payload = {};
        let raw = "";
        try {
          raw = await response.text();
          payload = raw ? JSON.parse(raw) : {};
        } catch {
          payload = raw ? { error: raw } : {};
        }

        if (!response.ok) {
          if (response.status === 401) {
            localStorage.removeItem(TOKEN_KEY);
            window.location.href = "/login";
          }
          if (response.status === 403) {
            const tokenPayload = parseJwt(token) || {};
            const identity =
              String(tokenPayload.email || tokenPayload["cognito:username"] || tokenPayload.username || "").trim() || "不明";
            throw new Error(`管理者権限が必要です（現在ログイン: ${identity}）。admin_emails 設定を確認してください。`);
          }
          const message = payload && payload.error ? String(payload.error) : `Request failed (${response.status})`;
          throw new Error(message);
        }

        return payload;
      }

      function setLine(target, kind, message) {
        target.dataset.kind = kind || "info";
        target.textContent = message || "";
      }

      function setEditorStatus(message, kind) {
        el.editorStatus.textContent = message || "";
        el.editorStatus.style.color = kind === "error" ? "#ffb7c3" : kind === "success" ? "var(--ok)" : "var(--muted)";
      }

      function setEditorSaveState(message, kind) {
        el.editorSaveState.textContent = message || "";
        el.editorSaveState.style.color = kind === "error" ? "#ffb7c3" : kind === "success" ? "var(--ok)" : "var(--muted)";
      }

      function setPatchStatus(kind, message) {
        setLine(el.patchStatus, kind || "info", message || "");
      }

      function renderPatchProposal() {
        const proposal = state.patchProposal;
        if (!proposal) {
          el.patchApplyBtn.disabled = true;
          el.patchRejectBtn.disabled = true;
          el.patchSummary.textContent = "";
          el.patchDiff.textContent = "";
          el.patchModelLabel.textContent = "";
          el.patchDiffPanel.hidden = true;
          return;
        }

        const stale = String(el.ipynbEditor.value || "") !== String(proposal.baseIpynbRaw || "");
        el.patchApplyBtn.disabled = state.patchGenerating || stale;
        el.patchRejectBtn.disabled = state.patchGenerating;
        el.patchSummary.textContent = proposal.summary || "提案概要はありません。";
        el.patchDiff.textContent = proposal.unifiedDiff || "(no changes)";
        el.patchModelLabel.textContent =
          proposal.modelLabel || proposal.tokensUsed ? `${proposal.modelLabel} | ${proposal.tokensUsed} tokens` : "";
        el.patchDiffPanel.hidden = false;

        if (stale) {
          setPatchStatus("warn", "ノート本文が変更されたため、この提案は再生成してください。");
        }
      }

      function clearPatchProposal(message, kind) {
        state.patchProposal = null;
        renderPatchProposal();
        if (message) {
          setPatchStatus(kind || "info", message);
        } else if (!state.patchGenerating) {
          setPatchStatus("info", "");
        }
      }

      function normalizeCatalogFromChapters(chapters) {
        const normalized = (Array.isArray(chapters) ? chapters : []).map((chapter, chapterIndex) => ({
          id: String(chapter.id || uid("chapter")),
          title: String(chapter.title || "").trim() || `セクション ${chapterIndex + 1}`,
          order: Number(chapter.order || chapterIndex + 1),
          notebooks: (Array.isArray(chapter.notebooks) ? chapter.notebooks : []).map((notebook, notebookIndex) => ({
            id: String(notebook.id || "").trim(),
            title: String(notebook.title || "").trim() || `Notebook ${notebookIndex + 1}`,
            order: Number(notebook.order || notebookIndex + 1),
            tags: Array.isArray(notebook.tags) ? notebook.tags.map((v) => String(v).trim()).filter(Boolean) : [],
            colabUrl: String(notebook.colabUrl || "").trim(),
            videoUrl: String(notebook.videoUrl || "").trim(),
            htmlPath: String(notebook.htmlPath || "")
          }))
          .filter((notebook) => notebook.id)
          .sort((a, b) => a.order - b.order)
        })).sort((a, b) => a.order - b.order);

        return reindexChapters(normalized);
      }

      function normalizeCatalogFromItems(items) {
        const chapters = [];
        const byTitle = new Map();

        (Array.isArray(items) ? items : []).forEach((item) => {
          const chapterTitle = String(item.chapter || "未分類").trim() || "未分類";
          let chapter = byTitle.get(chapterTitle);
          if (!chapter) {
            chapter = {
              id: uid("chapter"),
              title: chapterTitle,
              order: chapters.length + 1,
              notebooks: []
            };
            byTitle.set(chapterTitle, chapter);
            chapters.push(chapter);
          }

          const notebookId = String(item.notebookId || item.id || "").trim();
          if (!notebookId) return;

          chapter.notebooks.push({
            id: notebookId,
            title: String(item.title || notebookId).trim() || notebookId,
            order: Math.max(1, Number(item.sortOrder || item.order || chapter.notebooks.length + 1)),
            tags: Array.isArray(item.tags) ? item.tags.map((v) => String(v).trim()).filter(Boolean) : [],
            colabUrl: String(item.colabUrl || "").trim(),
            videoUrl: String(item.videoUrl || "").trim(),
            htmlPath: String(item.htmlPath || "")
          });
        });

        chapters.forEach((chapter) => {
          chapter.notebooks.sort((a, b) => a.order - b.order);
        });

        return reindexChapters(chapters);
      }

      function normalizeCatalog(payload) {
        if (payload && Array.isArray(payload.chapters)) {
          return normalizeCatalogFromChapters(payload.chapters);
        }
        if (payload && Array.isArray(payload.items)) {
          return normalizeCatalogFromItems(payload.items);
        }
        if (Array.isArray(payload)) {
          return normalizeCatalogFromChapters(payload);
        }
        return [];
      }

      function reindexChapters(chapters) {
        return chapters.map((chapter, chapterIndex) => ({
          ...chapter,
          order: chapterIndex + 1,
          notebooks: chapter.notebooks.map((notebook, notebookIndex) => ({
            ...notebook,
            order: notebookIndex + 1
          }))
        }));
      }

      function findChapter(chapterId) {
        return state.chapters.find((chapter) => chapter.id === chapterId) || null;
      }

      function findNotebook(notebookId) {
        for (const chapter of state.chapters) {
          const notebook = chapter.notebooks.find((item) => item.id === notebookId);
          if (notebook) return notebook;
        }
        return null;
      }

      function findNotebookLocation(notebookId) {
        for (const chapter of state.chapters) {
          const index = chapter.notebooks.findIndex((item) => item.id === notebookId);
          if (index >= 0) {
            return { chapter, index };
          }
        }
        return null;
      }

      function firstNotebookId() {
        for (const chapter of state.chapters) {
          if (chapter.notebooks.length > 0) return chapter.notebooks[0].id;
        }
        return "";
      }

      function getStructurePayload() {
        return state.chapters.map((chapter, chapterIndex) => ({
          id: chapter.id,
          title: chapter.title,
          order: chapterIndex + 1,
          notebooks: chapter.notebooks.map((notebook, notebookIndex) => ({
            id: notebook.id,
            title: notebook.title,
            order: notebookIndex + 1
          }))
        }));
      }

      function structureHash() {
        return JSON.stringify(getStructurePayload());
      }

      function updateCount() {
        const notebookCount = state.chapters.reduce((sum, chapter) => sum + chapter.notebooks.length, 0);
        el.countLabel.textContent = `${state.chapters.length} sections / ${notebookCount} notebooks`;
      }

      function renderUploadSectionOptions() {
        const options = state.chapters
          .map((chapter) => `<option value="${escapeHtml(chapter.id)}">${escapeHtml(chapter.title)}</option>`)
          .join("");
        el.uploadSectionSelect.innerHTML = `${options}<option value="__new">+ 新規セクションを作成</option>`;
      }

      function renderHeaderMeta() {
        const notebook = findNotebook(state.activeNotebookId);
        if (!notebook) {
          el.editorTitle.textContent = "ノート未選択";
          el.editorMeta.textContent = "ノートを選択してください。";
          el.metaNotebookId.value = "";
          el.metaTitle.value = "";
          el.metaChapter.value = "";
          el.metaTags.value = "";
          el.metaColab.value = "";
          el.metaVideo.value = "";
          return;
        }

        const location = findNotebookLocation(notebook.id);
        const chapterTitle = location ? location.chapter.title : "";
        el.editorTitle.textContent = notebook.title || notebook.id;
        el.editorMeta.textContent = `${notebook.id} | ${chapterTitle}${location ? ` / ${location.index + 1}番` : ""}`;
        el.metaNotebookId.value = notebook.id;
        el.metaTitle.value = notebook.title;
        el.metaChapter.value = chapterTitle;
        el.metaTags.value = notebook.tags.join(", ");
        el.metaColab.value = notebook.colabUrl || "";
        el.metaVideo.value = notebook.videoUrl || "";
      }

      function chapterTemplate(chapter) {
        const opened = state.openMap[chapter.id] !== false;
        const notebooksHtml = chapter.notebooks
          .map((notebook) => {
            const active = notebook.id === state.activeNotebookId;
            return `
              <article class="notebook-row${active ? " active" : ""}" data-notebook-id="${escapeHtml(notebook.id)}" data-chapter-id="${escapeHtml(chapter.id)}">
                <button class="drag-handle" draggable="true" data-drag-kind="notebook" data-notebook-id="${escapeHtml(notebook.id)}" data-from-chapter-id="${escapeHtml(chapter.id)}" type="button" aria-label="drag notebook">⋮⋮</button>
                <input class="notebook-input" data-role="notebook-title" value="${escapeHtml(notebook.title)}" />
                <button class="button-ghost" data-action="select-notebook" type="button">編集</button>
              </article>
            `;
          })
          .join("");

        return `
          <section class="chapter-card glass-soft" data-chapter-id="${escapeHtml(chapter.id)}">
            <div class="chapter-head" data-drop-chapter-id="${escapeHtml(chapter.id)}">
              <button class="drag-handle" draggable="true" data-drag-kind="chapter" data-chapter-id="${escapeHtml(chapter.id)}" type="button" aria-label="drag chapter">⋮⋮</button>
              <button class="caret" data-action="toggle-chapter" type="button">${opened ? "▾" : "▸"}</button>
              <input class="chapter-input" data-role="chapter-title" value="${escapeHtml(chapter.title)}" />
            </div>
            ${opened
              ? `<div class="chapter-drop" data-drop-list-chapter-id="${escapeHtml(chapter.id)}">${notebooksHtml || '<div class="empty-drop">ノートをここへドロップ</div>'}</div>`
              : ""}
          </section>
        `;
      }

      function renderCatalog() {
        updateCount();
        renderUploadSectionOptions();
        renderHeaderMeta();

        if (!state.chapters.length) {
          el.catalog.innerHTML = '<div class="glass-soft" style="padding:12px; color:var(--muted); font-size:13px;">教材がありません。下のフォームから ipynb を追加してください。</div>';
          return;
        }

        el.catalog.innerHTML = state.chapters.map(chapterTemplate).join("");
        bindCatalogEvents();
      }

      function moveChapter(sourceChapterId, targetChapterId) {
        if (!sourceChapterId || !targetChapterId || sourceChapterId === targetChapterId) return;
        const next = state.chapters.slice();
        const sourceIndex = next.findIndex((chapter) => chapter.id === sourceChapterId);
        const targetIndex = next.findIndex((chapter) => chapter.id === targetChapterId);
        if (sourceIndex < 0 || targetIndex < 0) return;

        const [source] = next.splice(sourceIndex, 1);
        next.splice(targetIndex, 0, source);
        state.chapters = reindexChapters(next);
        markStructureDirty("セクション順を変更しました。自動保存します...");
        renderCatalog();
      }

      function moveNotebook(notebookId, fromChapterId, toChapterId, beforeNotebookId) {
        if (!notebookId || !fromChapterId || !toChapterId) return;
        const next = state.chapters.map((chapter) => ({ ...chapter, notebooks: chapter.notebooks.slice() }));
        const fromChapter = next.find((chapter) => chapter.id === fromChapterId);
        const toChapter = next.find((chapter) => chapter.id === toChapterId);
        if (!fromChapter || !toChapter) return;

        const fromIndex = fromChapter.notebooks.findIndex((item) => item.id === notebookId);
        if (fromIndex < 0) return;

        const [moving] = fromChapter.notebooks.splice(fromIndex, 1);

        if (!beforeNotebookId) {
          toChapter.notebooks.push(moving);
        } else {
          const targetIndex = toChapter.notebooks.findIndex((item) => item.id === beforeNotebookId);
          if (targetIndex < 0) {
            toChapter.notebooks.push(moving);
          } else {
            toChapter.notebooks.splice(targetIndex, 0, moving);
          }
        }

        state.chapters = reindexChapters(next);
        markStructureDirty("ノート順を変更しました。自動保存します...");
        renderCatalog();
      }

      function clearDropHighlights() {
        el.catalog.querySelectorAll(".is-over").forEach((node) => node.classList.remove("is-over"));
      }

      function bindCatalogEvents() {
        el.catalog.querySelectorAll("[data-action='toggle-chapter']").forEach((button) => {
          button.addEventListener("click", function () {
            const chapterCard = button.closest("[data-chapter-id]");
            if (!chapterCard) return;
            const chapterId = chapterCard.getAttribute("data-chapter-id") || "";
            state.openMap[chapterId] = !(state.openMap[chapterId] !== false);
            renderCatalog();
          });
        });

        el.catalog.querySelectorAll("[data-role='chapter-title']").forEach((input) => {
          input.addEventListener("input", function () {
            const chapterCard = input.closest("[data-chapter-id]");
            if (!chapterCard) return;
            const chapterId = chapterCard.getAttribute("data-chapter-id") || "";
            const chapter = findChapter(chapterId);
            if (!chapter) return;
            chapter.title = String(input.value || "");
            markStructureDirty("セクション名を変更しました。自動保存します...");
            renderHeaderMeta();
          });
        });

        el.catalog.querySelectorAll("[data-role='notebook-title']").forEach((input) => {
          input.addEventListener("input", function () {
            const row = input.closest("[data-notebook-id]");
            if (!row) return;
            const notebookId = row.getAttribute("data-notebook-id") || "";
            const notebook = findNotebook(notebookId);
            if (!notebook) return;
            notebook.title = String(input.value || "");
            if (state.activeNotebookId === notebookId) {
              el.metaTitle.value = notebook.title;
              renderHeaderMeta();
              markNotebookDirty("ノート情報を更新しました。自動保存します...");
            }
            markStructureDirty("ノートタイトルを変更しました。自動保存します...");
          });
        });

        el.catalog.querySelectorAll("[data-action='select-notebook']").forEach((button) => {
          button.addEventListener("click", function () {
            const row = button.closest("[data-notebook-id]");
            if (!row) return;
            const notebookId = row.getAttribute("data-notebook-id") || "";
            if (!notebookId || notebookId === state.activeNotebookId) return;
            void setActiveNotebook(notebookId);
          });
        });

        el.catalog.querySelectorAll(".drag-handle[draggable='true']").forEach((handle) => {
          handle.addEventListener("dragstart", function (event) {
            const kind = handle.getAttribute("data-drag-kind") || "";
            if (kind === "chapter") {
              state.dragPayload = { kind: "chapter", chapterId: handle.getAttribute("data-chapter-id") || "" };
            } else if (kind === "notebook") {
              state.dragPayload = {
                kind: "notebook",
                notebookId: handle.getAttribute("data-notebook-id") || "",
                fromChapterId: handle.getAttribute("data-from-chapter-id") || ""
              };
            }
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = "move";
              event.dataTransfer.setData("text/plain", JSON.stringify(state.dragPayload || {}));
            }
          });

          handle.addEventListener("dragend", function () {
            state.dragPayload = null;
            clearDropHighlights();
          });
        });

        el.catalog.querySelectorAll("[data-drop-chapter-id]").forEach((target) => {
          target.addEventListener("dragover", function (event) {
            event.preventDefault();
            clearDropHighlights();
            target.classList.add("is-over");
          });

          target.addEventListener("drop", function (event) {
            event.preventDefault();
            clearDropHighlights();
            const targetChapterId = target.getAttribute("data-drop-chapter-id") || "";
            const payload = state.dragPayload;
            if (!payload || !targetChapterId) return;

            if (payload.kind === "chapter") {
              moveChapter(payload.chapterId, targetChapterId);
              return;
            }

            if (payload.kind === "notebook") {
              moveNotebook(payload.notebookId, payload.fromChapterId, targetChapterId, null);
            }
          });
        });

        el.catalog.querySelectorAll("[data-drop-list-chapter-id]").forEach((dropList) => {
          dropList.addEventListener("dragover", function (event) {
            event.preventDefault();
            clearDropHighlights();
            dropList.classList.add("is-over");
          });

          dropList.addEventListener("dragleave", function () {
            dropList.classList.remove("is-over");
          });

          dropList.addEventListener("drop", function (event) {
            event.preventDefault();
            clearDropHighlights();
            const payload = state.dragPayload;
            const targetChapterId = dropList.getAttribute("data-drop-list-chapter-id") || "";
            if (!payload || payload.kind !== "notebook" || !targetChapterId) return;

            const rows = Array.from(dropList.querySelectorAll("[data-notebook-id]"));
            const before = rows.find((row) => {
              const rect = row.getBoundingClientRect();
              return event.clientY < rect.top + rect.height / 2;
            });
            const beforeNotebookId = before ? before.getAttribute("data-notebook-id") || "" : "";
            moveNotebook(payload.notebookId, payload.fromChapterId, targetChapterId, beforeNotebookId || undefined);
          });
        });

        el.catalog.querySelectorAll(".notebook-row").forEach((row) => {
          row.addEventListener("click", function (event) {
            const target = event.target;
            if (target && target.closest && target.closest("button")) {
              return;
            }
            const notebookId = row.getAttribute("data-notebook-id") || "";
            if (!notebookId || notebookId === state.activeNotebookId) return;
            void setActiveNotebook(notebookId);
          });
        });
      }

      function validateStructureBeforeSave() {
        if (!state.chapters.length) {
          return "セクションがありません。";
        }

        for (const chapter of state.chapters) {
          if (!String(chapter.title || "").trim()) {
            return "空のセクション名は保存できません。";
          }
        }

        return "";
      }

      function markStructureDirty(message) {
        state.structureDirty = true;
        setLine(el.structureStatus, "warn", message || "構成に未保存の変更があります...");
        if (state.structureSaveTimer) {
          window.clearTimeout(state.structureSaveTimer);
        }
        state.structureSaveTimer = window.setTimeout(() => {
          void saveStructure(false);
        }, 900);
      }

      async function saveStructure(manual) {
        if (state.structureSaveTimer) {
          window.clearTimeout(state.structureSaveTimer);
          state.structureSaveTimer = 0;
        }

        const error = validateStructureBeforeSave();
        if (error) {
          setLine(el.structureStatus, "error", error);
          return false;
        }

        const payload = getStructurePayload();
        const nextHash = JSON.stringify(payload);
        if (!manual && !state.structureDirty && nextHash === state.savedStructureHash) {
          return true;
        }

        state.savingStructure = true;
        setLine(el.structureStatus, "info", manual ? "構成を保存中..." : "構成を自動保存中...");

        try {
          const updates = [];
          state.chapters.forEach((chapter) => {
            chapter.notebooks.forEach((notebook, index) => {
              updates.push({
                notebookId: notebook.id,
                title: notebook.title,
                chapter: chapter.title,
                sortOrder: index + 1,
                tags: notebook.tags,
                colabUrl: notebook.colabUrl,
                videoUrl: notebook.videoUrl || ""
              });
            });
          });

          for (const update of updates) {
            await api("/api/admin/notebooks", {
              method: "PATCH",
              headers: { "content-type": "application/json" },
              body: JSON.stringify(update)
            });
          }

          state.savingStructure = false;
          state.structureDirty = false;
          state.savedStructureHash = nextHash;
          setLine(
            el.structureStatus,
            "success",
            `${manual ? "構成を保存" : "構成を自動保存"}しました (${new Date().toLocaleTimeString()})`
          );
          return true;
        } catch (saveError) {
          state.savingStructure = false;
          setLine(el.structureStatus, "error", saveError instanceof Error ? saveError.message : String(saveError));
          return false;
        }
      }

      function markNotebookDirty(message) {
        state.notebookDirty = true;
        setEditorSaveState(message || "未保存の変更があります...", "warn");
        if (state.notebookSaveTimer) {
          window.clearTimeout(state.notebookSaveTimer);
        }
        state.notebookSaveTimer = window.setTimeout(() => {
          void saveActiveNotebook(false);
        }, 1300);
      }

      async function saveActiveNotebook(manual) {
        if (state.notebookSaveTimer) {
          window.clearTimeout(state.notebookSaveTimer);
          state.notebookSaveTimer = 0;
        }

        const notebookId = state.activeNotebookId;
        const notebook = findNotebook(notebookId);
        const location = findNotebookLocation(notebookId);
        if (!notebook || !location) {
          setEditorStatus("保存対象のノートがありません。", "error");
          return false;
        }

        const raw = String(el.ipynbEditor.value || "");
        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch {
          setEditorSaveState("JSON形式が不正です。修正後に保存されます。", "error");
          setEditorStatus("JSON形式が不正です。", "error");
          return false;
        }
        if (!parsed || typeof parsed !== "object") {
          setEditorSaveState("ipynb JSON が不正です。", "error");
          return false;
        }

        state.savingNotebook = true;
        setEditorSaveState(manual ? "保存中..." : "自動保存中...", "info");

        try {
          await api(`/api/admin/notebooks/${encodeURIComponent(notebookId)}`, {
            method: "PUT",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              title: notebook.title,
              chapter: location.chapter.title,
              sortOrder: location.index + 1,
              tags: notebook.tags,
              colabUrl: notebook.colabUrl,
              videoUrl: notebook.videoUrl || null,
              ipynbRaw: raw
            })
          });

          state.savingNotebook = false;
          state.notebookDirty = false;
          state.ipynbRaw = raw;
          state.ipynbSavedRaw = raw;
          const message = `${manual ? "保存" : "自動保存"}しました (${new Date().toLocaleTimeString()})`;
          setEditorSaveState(message, "success");
          setEditorStatus(`${notebookId} を保存しました。`, "success");
          return true;
        } catch (saveError) {
          state.savingNotebook = false;
          const message = saveError instanceof Error ? saveError.message : String(saveError);
          setEditorSaveState(message, "error");
          setEditorStatus(message, "error");
          return false;
        }
      }

      async function generatePatchProposal() {
        if (state.patchGenerating) return;
        const notebookId = String(state.activeNotebookId || "").trim();
        if (!notebookId) {
          setPatchStatus("error", "先にノートを選択してください。");
          return;
        }

        const instruction = String(el.patchInstruction.value || "").trim();
        if (!instruction) {
          setPatchStatus("error", "修正指示を入力してください。");
          return;
        }

        const raw = String(el.ipynbEditor.value || "");
        if (raw !== String(state.ipynbSavedRaw || "")) {
          setPatchStatus("warn", "未保存の変更があります。先に保存してから提案を生成してください。");
          return;
        }

        const selStart = Number(el.ipynbEditor.selectionStart || 0);
        const selEnd = Number(el.ipynbEditor.selectionEnd || 0);
        const selectedText = selEnd > selStart ? raw.slice(selStart, selEnd).slice(0, 8000) : "";

        state.patchGenerating = true;
        el.patchGenerateBtn.disabled = true;
        setPatchStatus("info", "LLMがパッチ提案を生成中...");
        renderPatchProposal();

        try {
          const result = await api(`/api/admin/notebooks/${encodeURIComponent(notebookId)}/llm-patch`, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              instruction,
              selectedText
            })
          });

          state.patchProposal = {
            notebookId,
            summary: String(result.summary || ""),
            baseIpynbRaw: String(result.currentIpynbRaw || ""),
            proposedIpynbRaw: String(result.proposedIpynbRaw || ""),
            unifiedDiff: String(result.unifiedDiff || ""),
            modelLabel: `${String(result.model?.provider || "")}:${String(result.model?.modelId || "")}`,
            tokensUsed: Number(result.tokensUsed || 0)
          };

          renderPatchProposal();
          setPatchStatus("success", `提案を生成しました (${new Date().toLocaleTimeString()})`);
        } catch (error) {
          clearPatchProposal();
          const message = error instanceof Error ? error.message : String(error);
          setPatchStatus("error", message);
        } finally {
          state.patchGenerating = false;
          el.patchGenerateBtn.disabled = false;
          renderPatchProposal();
        }
      }

      async function applyPatchProposal() {
        const proposal = state.patchProposal;
        if (!proposal) {
          setPatchStatus("warn", "採用できる提案がありません。");
          return;
        }

        if (proposal.notebookId !== state.activeNotebookId) {
          setPatchStatus("warn", "ノートが切り替わったため提案を再生成してください。");
          return;
        }

        const currentRaw = String(el.ipynbEditor.value || "");
        if (currentRaw !== String(proposal.baseIpynbRaw || "")) {
          setPatchStatus("warn", "本文が変更されているため採用できません。再生成してください。");
          renderPatchProposal();
          return;
        }

        if (!String(proposal.proposedIpynbRaw || "").trim()) {
          setPatchStatus("error", "提案内容が空です。");
          return;
        }

        el.ipynbEditor.value = proposal.proposedIpynbRaw;
        state.ipynbRaw = proposal.proposedIpynbRaw;
        markNotebookDirty("LLM提案を適用しました。保存します...");

        const saved = await saveActiveNotebook(true);
        if (saved) {
          clearPatchProposal("提案を採用して保存しました。", "success");
        } else {
          setPatchStatus("error", "採用後の保存に失敗しました。");
        }
      }

      function rejectPatchProposal() {
        if (!state.patchProposal) {
          setPatchStatus("warn", "却下する提案がありません。");
          return;
        }
        clearPatchProposal("提案を却下しました。", "info");
      }

      async function setActiveNotebook(notebookId) {
        const normalized = String(notebookId || "").trim();
        if (!normalized) {
          state.activeNotebookId = "";
          state.ipynbRaw = "";
          state.ipynbSavedRaw = "";
          el.ipynbEditor.value = "";
          clearPatchProposal();
          renderHeaderMeta();
          setEditorSaveState("自動保存: 待機中", "info");
          setEditorStatus("ノートを選択してください。", "info");
          return;
        }

        state.activeNotebookId = normalized;
        clearPatchProposal();
        renderCatalog();

        state.loadSeq += 1;
        const loadSeq = state.loadSeq;
        setEditorStatus("ipynbを読み込み中...", "info");
        setEditorSaveState("読み込み中...", "info");

        try {
          const payload = await api(`/api/admin/notebooks/${encodeURIComponent(normalized)}`, { method: "GET" });
          if (loadSeq !== state.loadSeq || state.activeNotebookId !== normalized) {
            return;
          }

          const notebook = findNotebook(normalized);
          if (notebook && payload.notebook) {
            notebook.title = String(payload.notebook.title || notebook.title);
            notebook.tags = Array.isArray(payload.notebook.tags)
              ? payload.notebook.tags.map((v) => String(v).trim()).filter(Boolean)
              : notebook.tags;
            notebook.colabUrl = String(payload.notebook.colabUrl || notebook.colabUrl);
            notebook.videoUrl = String(payload.notebook.videoUrl || notebook.videoUrl || "");
            notebook.htmlPath = String(payload.notebook.htmlPath || notebook.htmlPath || "");
          }

          state.ipynbRaw = String(payload.ipynbRaw || "");
          state.ipynbSavedRaw = state.ipynbRaw;
          state.notebookDirty = false;
          el.ipynbEditor.value = state.ipynbRaw;

          renderCatalog();
          setEditorSaveState("自動保存: 待機中", "info");
          setEditorStatus(`${normalized} を読み込みました。`, "success");
        } catch (loadError) {
          const message = loadError instanceof Error ? loadError.message : String(loadError);
          setEditorSaveState(message, "error");
          setEditorStatus(message, "error");
        }
      }

      async function loadCatalog() {
        setLine(el.structureStatus, "info", "教材一覧を読み込み中...");
        try {
          const payload = await api("/api/admin/notebooks", { method: "GET" });
          state.chapters = normalizeCatalog(payload);

          const nextOpenMap = {};
          state.chapters.forEach((chapter) => {
            nextOpenMap[chapter.id] = chapter.id in state.openMap ? state.openMap[chapter.id] : true;
          });
          state.openMap = nextOpenMap;

          if (!findNotebook(state.activeNotebookId)) {
            state.activeNotebookId = firstNotebookId();
          }

          state.savedStructureHash = structureHash();
          state.structureDirty = false;

          renderCatalog();
          setLine(el.structureStatus, "success", `教材一覧を更新しました (${new Date().toLocaleTimeString()})`);

          if (state.activeNotebookId) {
            await setActiveNotebook(state.activeNotebookId);
          } else {
            await setActiveNotebook("");
          }
        } catch (loadError) {
          const message = loadError instanceof Error ? loadError.message : String(loadError);
          state.chapters = [];
          renderCatalog();
          setLine(el.structureStatus, "error", `Load failed: ${message}`);
        }
      }

      function appendSection() {
        const existingTitles = new Set(state.chapters.map((chapter) => chapter.title));
        let nextIndex = 1;
        let nextTitle = "新しいセクション";
        while (existingTitles.has(nextTitle)) {
          nextIndex += 1;
          nextTitle = `新しいセクション ${nextIndex}`;
        }
        const chapterId = uid("chapter");
        state.chapters.push({
          id: chapterId,
          title: nextTitle,
          order: state.chapters.length + 1,
          notebooks: []
        });
        state.chapters = reindexChapters(state.chapters);
        state.openMap[chapterId] = true;
        renderCatalog();
        markStructureDirty("セクションを追加しました。自動保存します...");
      }

      async function handleUpload(event) {
        event.preventDefault();
        setLine(el.uploadStatus, "info", "アップロード中...");
        el.uploadBtn.disabled = true;

        try {
          const form = new FormData(el.uploadForm);
          const selectedChapterId = String(form.get("sectionSelect") || "").trim();
          const newSectionTitle = String(form.get("newSection") || "").trim();

          let chapterTitle = "";
          if (selectedChapterId === "__new") {
            chapterTitle = newSectionTitle;
          } else {
            const selectedChapter = findChapter(selectedChapterId);
            chapterTitle = selectedChapter ? selectedChapter.title : "";
          }
          chapterTitle = chapterTitle.trim();
          if (!chapterTitle) {
            throw new Error("アップロード先セクションを選択するか、新規セクション名を入力してください。");
          }

          const title = String(form.get("title") || "").trim();
          const colabUrl = String(form.get("colabUrl") || "").trim();
          const file = form.get("file");
          if (!title || !colabUrl || !(file instanceof File)) {
            throw new Error("タイトル / Colab URL / ipynb ファイルは必須です。");
          }

          const targetChapter = state.chapters.find((chapter) => chapter.title === chapterTitle);
          const order = targetChapter ? targetChapter.notebooks.length + 1 : 1;

          const submit = new FormData();
          submit.set("title", title);
          submit.set("chapter", chapterTitle);
          submit.set("order", String(order));
          submit.set("tags", String(form.get("tags") || ""));
          submit.set("colabUrl", colabUrl);
          submit.set("videoUrl", String(form.get("videoUrl") || ""));
          submit.set("file", file);

          const result = await api("/api/admin/notebooks", {
            method: "POST",
            body: submit
          });

          setLine(el.uploadStatus, "success", `登録しました: ${result.notebookId || title}`);
          el.uploadForm.reset();

          await loadCatalog();
          if (result.notebookId) {
            await setActiveNotebook(String(result.notebookId));
          }
        } catch (uploadError) {
          const message = uploadError instanceof Error ? uploadError.message : String(uploadError);
          setLine(el.uploadStatus, "error", message);
        } finally {
          el.uploadBtn.disabled = false;
        }
      }

      async function saveAllNow() {
        el.manualSaveBtn.disabled = true;
        setEditorStatus("保存処理を実行中...", "info");

        try {
          const structureOk = await saveStructure(true);
          const notebookOk = state.activeNotebookId ? await saveActiveNotebook(true) : true;

          if (structureOk && notebookOk) {
            setEditorStatus("構成とノートを保存しました。", "success");
          }
        } finally {
          el.manualSaveBtn.disabled = false;
        }
      }

      function bindTopLevelEvents() {
        el.addSectionBtn.addEventListener("click", appendSection);
        el.reloadCatalogBtn.addEventListener("click", function () {
          void loadCatalog();
        });
        el.uploadForm.addEventListener("submit", function (event) {
          void handleUpload(event);
        });
        el.logoutBtn.addEventListener("click", function () {
          localStorage.removeItem(TOKEN_KEY);
          window.location.href = "/login";
        });
        el.manualSaveBtn.addEventListener("click", function () {
          void saveAllNow();
        });
        el.reloadNotebookBtn.addEventListener("click", function () {
          void setActiveNotebook(state.activeNotebookId);
        });
        el.patchGenerateBtn.addEventListener("click", function () {
          void generatePatchProposal();
        });
        el.patchApplyBtn.addEventListener("click", function () {
          void applyPatchProposal();
        });
        el.patchRejectBtn.addEventListener("click", function () {
          rejectPatchProposal();
        });

        el.ipynbEditor.addEventListener("input", function () {
          state.ipynbRaw = String(el.ipynbEditor.value || "");
          renderPatchProposal();
          markNotebookDirty("ノート本文を変更しました。自動保存します...");
        });

        el.metaTitle.addEventListener("input", function () {
          const notebook = findNotebook(state.activeNotebookId);
          if (!notebook) return;
          notebook.title = String(el.metaTitle.value || "");
          renderCatalog();
          markStructureDirty("タイトルを変更しました。自動保存します...");
          markNotebookDirty("ノート情報を変更しました。自動保存します...");
        });

        el.metaTags.addEventListener("input", function () {
          const notebook = findNotebook(state.activeNotebookId);
          if (!notebook) return;
          notebook.tags = String(el.metaTags.value || "")
            .split(",")
            .map((v) => v.trim())
            .filter(Boolean);
          markNotebookDirty("タグを変更しました。自動保存します...");
        });

        el.metaColab.addEventListener("input", function () {
          const notebook = findNotebook(state.activeNotebookId);
          if (!notebook) return;
          notebook.colabUrl = String(el.metaColab.value || "").trim();
          markNotebookDirty("Colab URL を変更しました。自動保存します...");
        });

        el.metaVideo.addEventListener("input", function () {
          const notebook = findNotebook(state.activeNotebookId);
          if (!notebook) return;
          notebook.videoUrl = String(el.metaVideo.value || "").trim();
          markNotebookDirty("Video URL を変更しました。自動保存します...");
        });

        window.addEventListener("beforeunload", function (event) {
          if (state.structureDirty || state.notebookDirty || state.savingStructure || state.savingNotebook) {
            event.preventDefault();
            event.returnValue = "";
          }
        });
      }

      requireLogin();
      bindTopLevelEvents();
      renderPatchProposal();
      void loadCatalog();
    })();
  </script>
</body>
</html>
