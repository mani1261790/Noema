<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>matplotlib-seaborn</title>
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <link rel="stylesheet" href="/katex/katex.min.css" />
  <style>
    :root {
      --bg-0: #f3f8fb;
      --bg-1: #d7e8f4;
      --bg-2: #f9f1e7;
      --text: #09162b;
      --muted: #44556f;
      --panel: rgba(255,255,255,.72);
      --border: rgba(255,255,255,.62);
      --code-bg: #09131a;
      --code-text: #e6f0f5;
      --shadow: 0 24px 54px rgba(10, 26, 54, 0.18), inset 0 1px 0 rgba(255,255,255,.62);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-0: #071225;
        --bg-1: #0f2238;
        --bg-2: #1a2f44;
        --text: #ebf3ff;
        --muted: #9db3cf;
        --panel: rgba(12, 21, 40, 0.74);
        --border: rgba(145, 183, 227, 0.33);
        --code-bg: #040b17;
        --code-text: #e4efff;
        --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1rem;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 12% 12%, rgba(87,196,223,.18), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 24px;
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(145%);
      -webkit-backdrop-filter: blur(20px) saturate(145%);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.25rem 1.5rem;
    }
    .prose-noema h1, .prose-noema h2, .prose-noema h3 {
      line-height: 1.25;
      margin-top: 1.25rem;
      margin-bottom: .65rem;
    }
    .prose-noema h1 { margin-top: .1rem; font-size: 1.8rem; }
    .prose-noema h2 { font-size: 1.35rem; }
    .prose-noema p {
      line-height: 1.85;
      color: var(--text);
      margin: .7rem 0;
    }
    .prose-noema ul, .prose-noema ol {
      margin: .7rem 0;
      padding-left: 1.4rem;
    }
    .prose-noema ul { list-style: disc; }
    .prose-noema ol { list-style: decimal; }
    .prose-noema li { margin: .28rem 0; line-height: 1.72; }
    .prose-noema a { color: inherit; text-underline-offset: 2px; }
    .prose-noema pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 12px;
      padding: 1rem;
      overflow: auto;
      border: 1px solid rgba(255,255,255,.12);
    }
    .prose-noema code {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .prose-noema img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <main>
<article class="prose-noema">
<h1 id="matplotlibとseabornの使い方">MatplotlibとSeabornの使い方</h1>
<p>可視化は「数表だけでは見えない傾向」を発見するための手段です。<br>
Matplotlib は柔軟な描画基盤、Seaborn は統計可視化を短いコードで書くための拡張です。</p>
<p>このノートでは、折れ線・散布図・ヒストグラム・カテゴリ比較を実データ風の例で確認します。</p>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style=&quot;whitegrid&quot;, context=&quot;notebook&quot;)</code></pre>
<p>まずは折れ線グラフ。時系列の増減を見るときに使います。</p>

<pre><code class="language-python">days = np.arange(1, 11)
loss = np.array([1.8, 1.5, 1.3, 1.15, 1.05, 0.96, 0.90, 0.86, 0.82, 0.79])

fig, ax = plt.subplots(figsize=(6, 3.5))
ax.plot(days, loss, marker=&quot;o&quot;, linewidth=2)
ax.set_title(&quot;Training Loss&quot;)
ax.set_xlabel(&quot;Epoch&quot;)
ax.set_ylabel(&quot;Loss&quot;)
plt.show()</code></pre>
<p>散布図は、2 変数の関係を見るときの第一選択です。<br>
ここでは「学習時間が増えると点数が上がる」という仮想データを作るために、<br>
<code>uniform</code> で学習時間、<code>normal</code> でノイズを発生させています。</p>

<pre><code class="language-python">rng = np.random.default_rng(7)
hours = rng.uniform(1, 8, size=80)
score = 52 + hours * 6 + rng.normal(0, 6, size=80)

fig, ax = plt.subplots(figsize=(5.5, 4))
ax.scatter(hours, score, alpha=0.75)
ax.set_title(&quot;Study Hours vs Score&quot;)
ax.set_xlabel(&quot;Hours&quot;)
ax.set_ylabel(&quot;Score&quot;)
plt.show()</code></pre>
<p>ヒストグラムは分布の形を確認するために使います。ビン数を変えると見え方が変わる点も重要です。</p>

<pre><code class="language-python">fig, axes = plt.subplots(1, 2, figsize=(10, 3.5), sharey=True)
axes[0].hist(score, bins=8, color=&quot;#4C78A8&quot;, alpha=0.85)
axes[0].set_title(&quot;bins=8&quot;)
axes[1].hist(score, bins=20, color=&quot;#F58518&quot;, alpha=0.85)
axes[1].set_title(&quot;bins=20&quot;)
for ax in axes:
    ax.set_xlabel(&quot;Score&quot;)
axes[0].set_ylabel(&quot;Count&quot;)
plt.tight_layout()
plt.show()</code></pre>
<p>カテゴリ比較では、箱ひげ図や棒グラフが便利です。Seaborn はこの部分を短く書けます。</p>
<p>この例では <code>np.repeat</code> でクラスラベルを増やし、<br>
<code>np.concatenate</code> でクラスごとに分布の違うスコア列を連結して、<br>
「クラスごとのばらつき」を比較できる形にしています。</p>

<pre><code class="language-python">df = pd.DataFrame({
    &quot;class&quot;: np.repeat([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], repeats=30),
    &quot;score&quot;: np.concatenate([
        rng.normal(70, 7, size=30),
        rng.normal(78, 6, size=30),
        rng.normal(74, 8, size=30),
    ])
})

fig, ax = plt.subplots(figsize=(6, 4))
sns.boxplot(data=df, x=&quot;class&quot;, y=&quot;score&quot;, ax=ax)
ax.set_title(&quot;Score Distribution by Class&quot;)
plt.show()</code></pre>
<p>複数系列の比較は、<code>hue</code> を使うと情報を整理しやすくなります。<br>
この例では baseline と improved を同じ軸で比較し、<br>
improved の曲線がより早く高い精度に到達しているかを読むのがポイントです。</p>

<pre><code class="language-python">df2 = pd.DataFrame({
    &quot;week&quot;: np.tile(np.arange(1, 7), 2),
    &quot;accuracy&quot;: np.concatenate([
        np.array([0.61, 0.66, 0.70, 0.74, 0.77, 0.79]),
        np.array([0.58, 0.64, 0.69, 0.72, 0.75, 0.78]),
    ]),
    &quot;model&quot;: [&quot;baseline&quot;] * 6 + [&quot;improved&quot;] * 6,
})

fig, ax = plt.subplots(figsize=(6, 3.8))
sns.lineplot(data=df2, x=&quot;week&quot;, y=&quot;accuracy&quot;, hue=&quot;model&quot;, marker=&quot;o&quot;, ax=ax)
ax.set_ylim(0.55, 0.82)
ax.set_title(&quot;Validation Accuracy&quot;)
plt.show()</code></pre>
<p>相関行列ヒートマップは、特徴量同士の関係を俯瞰するときに便利です。</p>

<pre><code class="language-python">feature_df = pd.DataFrame({
    &quot;math&quot;: rng.normal(75, 10, size=120),
    &quot;english&quot;: rng.normal(73, 9, size=120),
    &quot;science&quot;: rng.normal(70, 11, size=120),
    &quot;study_hours&quot;: rng.normal(4.5, 1.2, size=120),
})

corr = feature_df.corr(numeric_only=True)
fig, ax = plt.subplots(figsize=(5, 4.2))
sns.heatmap(corr, annot=True, cmap=&quot;Blues&quot;, vmin=-1, vmax=1, ax=ax)
ax.set_title(&quot;Correlation Matrix&quot;)
plt.show()</code></pre>
<p>可視化では、見た目を整える前に「何を比較したいか」を先に決めることが重要です。<br>
目的が定まると、グラフ種類・軸・色分けの選択がぶれにくくなります。</p>

</article>
  </main>
  <script src="/highlight/highlight.min.js"></script>
  <script>
    (function () {
      if (!window.hljs) return;
      document.querySelectorAll("pre code").forEach(function (block) {
        window.hljs.highlightElement(block);
      });
    })();
  </script>
</body>
</html>