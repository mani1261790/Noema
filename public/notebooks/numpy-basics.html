<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>numpy-basics</title>
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <link rel="stylesheet" href="/katex/katex.min.css" />
  <style>
    :root {
      --bg-0: #f3f8fb;
      --bg-1: #d7e8f4;
      --bg-2: #f9f1e7;
      --text: #09162b;
      --muted: #44556f;
      --panel: rgba(255,255,255,.72);
      --border: rgba(255,255,255,.62);
      --code-bg: #09131a;
      --code-text: #e6f0f5;
      --shadow: 0 24px 54px rgba(10, 26, 54, 0.18), inset 0 1px 0 rgba(255,255,255,.62);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-0: #071225;
        --bg-1: #0f2238;
        --bg-2: #1a2f44;
        --text: #ebf3ff;
        --muted: #9db3cf;
        --panel: rgba(12, 21, 40, 0.74);
        --border: rgba(145, 183, 227, 0.33);
        --code-bg: #040b17;
        --code-text: #e4efff;
        --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1rem;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 12% 12%, rgba(87,196,223,.18), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 24px;
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(145%);
      -webkit-backdrop-filter: blur(20px) saturate(145%);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.25rem 1.5rem;
    }
    .prose-noema h1, .prose-noema h2, .prose-noema h3 {
      line-height: 1.25;
      margin-top: 1.25rem;
      margin-bottom: .65rem;
    }
    .prose-noema h1 { margin-top: .1rem; font-size: 1.8rem; }
    .prose-noema h2 { font-size: 1.35rem; }
    .prose-noema p {
      line-height: 1.85;
      color: var(--text);
      margin: .7rem 0;
    }
    .prose-noema ul, .prose-noema ol {
      margin: .7rem 0;
      padding-left: 1.4rem;
    }
    .prose-noema ul { list-style: disc; }
    .prose-noema ol { list-style: decimal; }
    .prose-noema li { margin: .28rem 0; line-height: 1.72; }
    .prose-noema a { color: inherit; text-underline-offset: 2px; }
    .prose-noema pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 12px;
      padding: 1rem;
      overflow: auto;
      border: 1px solid rgba(255,255,255,.12);
    }
    .prose-noema code {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .prose-noema img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <main>
<article class="prose-noema">
<h1 id="numpyの使い方">NumPyの使い方</h1>
<p>NumPy は、数値データを高速に扱うための配列ライブラリです。Python のリストよりも、<br>
<code>同じ型の数値を大量に計算する</code> 場面で強みを発揮します。</p>
<p>このノートでは、配列の形（shape）と演算規則（broadcast）を軸に、分析でよく使う操作を一通り確認します。</p>

<pre><code class="language-python">import numpy as np</code></pre>
<p>まずは <code>ndarray</code> の基本です。shape と dtype を見る習慣をつけると、<br>
行列計算のエラー原因を早く特定できます。</p>

<pre><code class="language-python">a = np.array([1, 2, 3, 4], dtype=np.float64)
b = np.array([[10, 20], [30, 40], [50, 60]])

print(&quot;a:&quot;, a)
print(&quot;a.shape:&quot;, a.shape, &quot;a.dtype:&quot;, a.dtype)
print(&quot;b:\n&quot;, b)
print(&quot;b.shape:&quot;, b.shape, &quot;b.dtype:&quot;, b.dtype)</code></pre>
<p>要素ごとの演算は NumPy の基本です。四則演算・比較演算を配列全体に対して直接書けます。</p>

<pre><code class="language-python">x = np.array([1.0, 2.0, 3.0, 4.0])
y = np.array([2.0, 4.0, 6.0, 8.0])

print(&quot;x + y:&quot;, x + y)
print(&quot;x * y:&quot;, x * y)
print(&quot;x / y:&quot;, x / y)
print(&quot;x &gt;= 2.5:&quot;, x &gt;= 2.5)</code></pre>
<p>ブロードキャストは「次元が違っても計算できるように拡張する」仕組みです。<br>
ここでは <code>matrix.shape == (3, 3)</code> と <code>offset.shape == (3,)</code> ですが、<br>
NumPy は <code>offset</code> を各行に複製した形として解釈し、行ごとに加算します。</p>

<pre><code class="language-python">matrix = np.array([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]])
offset = np.array([10., 20., 30.])

print(&quot;matrix.shape:&quot;, matrix.shape)
print(&quot;offset.shape:&quot;, offset.shape)
print(&quot;matrix + offset:\n&quot;, matrix + offset)</code></pre>
<p>インデキシングは、行列から欲しい部分を抜き出すための必須スキルです。<br>
スライスとブールマスクを使えるようになると、前処理がかなり書きやすくなります。</p>
<p>ブールマスクは <code>True/False</code> の配列で、<code>True</code> の位置の要素だけを取り出します。</p>

<pre><code class="language-python">arr = np.arange(1, 13).reshape(3, 4)
print(&quot;arr:\n&quot;, arr)
print(&quot;2行目:&quot;, arr[1])
print(&quot;1〜2行, 2〜4列:\n&quot;, arr[0:2, 1:4])

mask = arr % 2 == 0
print(&quot;mask:\n&quot;, mask)
print(&quot;偶数だけ:&quot;, arr[mask])</code></pre>
<p>集約操作（sum, mean, max）は <code>axis</code> を意識するのがポイントです。<br>
<code>axis=0</code> は列方向、<code>axis=1</code> は行方向の集約を意味します。</p>

<pre><code class="language-python">scores = np.array([[72, 88, 65], [91, 77, 84], [68, 79, 95]])

print(&quot;全体平均:&quot;, scores.mean())
print(&quot;科目ごとの平均(axis=0):&quot;, scores.mean(axis=0))
print(&quot;学生ごとの合計(axis=1):&quot;, scores.sum(axis=1))</code></pre>
<p>線形代数の演算は、ニューラルネットワークの実装理解にも直結します。<br>
<code>@</code> 演算子で行列積を書けます。</p>

<pre><code class="language-python">W = np.array([[0.2, -0.3], [0.4, 0.1], [0.5, -0.2]])
x = np.array([1.0, 2.0, -1.0])
b = np.array([0.1, -0.2])

logits = x @ W + b
print(&quot;logits:&quot;, logits)</code></pre>
<p>乱数生成では、再現性のためにシード固定を先に行うのが実務上の基本です。</p>

<pre><code class="language-python">rng = np.random.default_rng(seed=42)
samples = rng.normal(loc=0.0, scale=1.0, size=(5, 3))

print(samples)
print(&quot;列平均:&quot;, samples.mean(axis=0))</code></pre>
<p>最後に、標準化（平均0・分散1）を NumPy で実装します。<br>
これは多くの機械学習アルゴリズムで前処理として使います。</p>

<pre><code class="language-python">features = np.array([
    [160, 55],
    [170, 68],
    [175, 70],
    [180, 80],
], dtype=np.float64)

mu = features.mean(axis=0)
sigma = features.std(axis=0)
scaled = (features - mu) / sigma

print(&quot;mu:&quot;, mu)
print(&quot;sigma:&quot;, sigma)
print(&quot;scaled:\n&quot;, scaled)
print(&quot;scaled mean:&quot;, scaled.mean(axis=0))</code></pre>
<p>NumPy は「配列の形を正しく管理しながらまとめて計算する」ための道具です。<br>
shape と axis を都度確認する癖が、バグを減らす最短ルートです。</p>

</article>
  </main>
  <script src="/highlight/highlight.min.js"></script>
  <script>
    (function () {
      if (!window.hljs) return;
      document.querySelectorAll("pre code").forEach(function (block) {
        window.hljs.highlightElement(block);
      });
    })();
  </script>
</body>
</html>