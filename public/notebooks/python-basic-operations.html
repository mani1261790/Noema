<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>python-basic-operations</title>
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <link rel="stylesheet" href="/katex/katex.min.css" />
  <style>
    :root {
      --bg-0: #f3f8fb;
      --bg-1: #d7e8f4;
      --bg-2: #f9f1e7;
      --text: #09162b;
      --muted: #44556f;
      --panel: rgba(255,255,255,.72);
      --border: rgba(255,255,255,.62);
      --code-bg: #09131a;
      --code-text: #e6f0f5;
      --shadow: 0 24px 54px rgba(10, 26, 54, 0.18), inset 0 1px 0 rgba(255,255,255,.62);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-0: #071225;
        --bg-1: #0f2238;
        --bg-2: #1a2f44;
        --text: #ebf3ff;
        --muted: #9db3cf;
        --panel: rgba(12, 21, 40, 0.74);
        --border: rgba(145, 183, 227, 0.33);
        --code-bg: #040b17;
        --code-text: #e4efff;
        --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1rem;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 12% 12%, rgba(87,196,223,.18), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 24px;
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(145%);
      -webkit-backdrop-filter: blur(20px) saturate(145%);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.25rem 1.5rem;
    }
    .prose-noema h1, .prose-noema h2, .prose-noema h3 {
      line-height: 1.25;
      margin-top: 1.25rem;
      margin-bottom: .65rem;
    }
    .prose-noema h1 { margin-top: .1rem; font-size: 1.8rem; }
    .prose-noema h2 { font-size: 1.35rem; }
    .prose-noema p {
      line-height: 1.85;
      color: var(--text);
      margin: .7rem 0;
    }
    .prose-noema ul, .prose-noema ol {
      margin: .7rem 0;
      padding-left: 1.4rem;
    }
    .prose-noema ul { list-style: disc; }
    .prose-noema ol { list-style: decimal; }
    .prose-noema li { margin: .28rem 0; line-height: 1.72; }
    .prose-noema a { color: inherit; text-underline-offset: 2px; }
    .prose-noema pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 12px;
      padding: 1rem;
      overflow: auto;
      border: 1px solid rgba(255,255,255,.12);
    }
    .prose-noema code {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .prose-noema img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <main>
<article class="prose-noema">
<h1 id="基本的なpythonの操作">基本的なPythonの操作</h1>
<p>Python は「手順を短く、読みやすく書く」ことに向いた言語です。機械学習の前処理や分析では、<br>
大量のデータに対して同じ操作を繰り返す場面が多く、まずは <code>値の持ち方</code> と <code>処理の分岐</code> を確実に押さえることが重要です。</p>
<p>このノートでは、変数・コレクション・条件分岐・反復・関数までを、実際に値を確認しながら進めます。</p>

<pre><code class="language-python">import math
from collections import Counter</code></pre>
<p><code>type</code> は「いま持っている値の性質」を確認する基本ツールです。Python は動的型付けなので、<br>
コードを書いている途中でも型を観察しながら進めるとミスを減らせます。</p>

<pre><code class="language-python">name = &quot;Noema&quot;
students = 32
completion_ratio = 0.45

print(type(name), type(students), type(completion_ratio))
print(f&quot;{name}: {students}人, 完了率 {completion_ratio:.0%}&quot;)</code></pre>
<p>リスト・辞書・集合は、用途が異なる 3 つの基本コンテナです。</p>
<ul>
<li>リスト: 順序を保って並べたい</li>
<li>辞書: キーで高速に参照したい</li>
<li>集合: 重複を除いて要素の存在を扱いたい</li>
</ul>
<p>同じデータでも、目的に応じて構造を選ぶとコードが一気に読みやすくなります。</p>

<pre><code class="language-python">scores = [72, 88, 65, 91, 88]
profile = {&quot;name&quot;: &quot;Aiko&quot;, &quot;grade&quot;: 1, &quot;club&quot;: &quot;AI&quot;}
unique_scores = set(scores)

print(&quot;scores:&quot;, scores)
print(&quot;profile[&#39;club&#39;]:&quot;, profile[&quot;club&quot;])
print(&quot;unique_scores:&quot;, unique_scores)</code></pre>
<p>インデックスとスライスは、配列の一部を抜き出すときの標準手段です。<br>
とくに <code>start:end</code> は end を含まないので、境界のミスに注意します。</p>

<pre><code class="language-python">print(&quot;先頭:&quot;, scores[0])
print(&quot;末尾:&quot;, scores[-1])
print(&quot;2番目から4番目手前:&quot;, scores[1:4])
print(&quot;2個おき:&quot;, scores[::2])</code></pre>
<p><code>if / elif / else</code> は条件分岐、<code>for</code> は反復処理です。<br>
点数に応じてラベルを付ける処理を実装すると、分岐とループの関係が見えます。</p>
<p>出力では <code>zip(scores, labels)</code> を使っています。<code>zip</code> は同じ位置の要素を組にして、<br>
<code>(score, label)</code> のタプル列を作る関数です。</p>

<pre><code class="language-python">labels = []
for score in scores:
    if score &gt;= 90:
        labels.append(&quot;A&quot;)
    elif score &gt;= 75:
        labels.append(&quot;B&quot;)
    else:
        labels.append(&quot;C&quot;)

print(list(zip(scores, labels)))</code></pre>
<p>リスト内包表記は、単純な変換を短く安全に書くための記法です。<br>
まず通常の <code>for</code> を書いて意味を確認し、次に内包表記へ圧縮する流れが初心者には理解しやすいです。</p>

<pre><code class="language-python"># 通常の for
squared_for = []
for x in range(1, 6):
    squared_for.append(x * x)

# 内包表記
squared_comp = [x * x for x in range(1, 6)]

print(squared_for)
print(squared_comp)</code></pre>
<p>関数は「処理に名前をつけて再利用する」ための仕組みです。<br>
入力を引数、出力を戻り値として明確にすると、分析コードの保守が楽になります。</p>

<pre><code class="language-python">def summarize_scores(values):
    count = len(values)
    avg = sum(values) / count
    best = max(values)
    worst = min(values)
    return {&quot;count&quot;: count, &quot;avg&quot;: avg, &quot;best&quot;: best, &quot;worst&quot;: worst}

summary = summarize_scores(scores)
print(summary)</code></pre>
<p>例外処理は「壊れる可能性がある場所」を明示するために使います。<br>
数値変換の失敗を握りつぶすのではなく、<code>except</code> で理由を扱う習慣をつけると、後でデバッグしやすくなります。</p>

<pre><code class="language-python">raw_inputs = [&quot;12&quot;, &quot;7&quot;, &quot;oops&quot;, &quot;20&quot;]
parsed = []

for item in raw_inputs:
    try:
        parsed.append(int(item))
    except ValueError:
        print(f&quot;変換失敗: {item}&quot;)

print(&quot;parsed:&quot;, parsed)</code></pre>
<p>最後に、ここまでの要素を合わせた小さな分析パターンを確認します。<br>
文字列ラベルの頻度集計や平均値の算出は、機械学習の前処理でも頻出です。</p>
<p><code>Counter</code> は「値ごとの出現回数」を数えるためのクラスで、<br>
<code>Counter(labels)</code> のように渡すと <code>{'A': 回数, 'B': 回数, ...}</code> を返します。</p>

<pre><code class="language-python">label_counter = Counter(labels)
avg_score = sum(scores) / len(scores)
std_score = math.sqrt(sum((x - avg_score) ** 2 for x in scores) / len(scores))

print(&quot;label count:&quot;, label_counter)
print(f&quot;average={avg_score:.2f}, std={std_score:.2f}&quot;)</code></pre>
<p>Python 基礎で大切なのは、文法暗記よりも「どの構造で値を持つか」「分岐と反復をどう組み合わせるか」を自然に選べることです。<br>
このノートのコードを少し書き換えながら、どの変更で出力がどう変わるかを確認してみてください。</p>

</article>
  </main>
  <script src="/highlight/highlight.min.js"></script>
  <script>
    (function () {
      if (!window.hljs) return;
      document.querySelectorAll("pre code").forEach(function (block) {
        window.hljs.highlightElement(block);
      });
    })();
  </script>
</body>
</html>