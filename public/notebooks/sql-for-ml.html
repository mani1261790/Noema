<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>sql-for-ml</title>
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <link rel="stylesheet" href="/katex/katex.min.css" />
  <style>
    :root {
      --bg-0: #f3f8fb;
      --bg-1: #d7e8f4;
      --bg-2: #f9f1e7;
      --text: #09162b;
      --muted: #44556f;
      --panel: rgba(255,255,255,.72);
      --border: rgba(255,255,255,.62);
      --code-bg: #09131a;
      --code-text: #e6f0f5;
      --shadow: 0 24px 54px rgba(10, 26, 54, 0.18), inset 0 1px 0 rgba(255,255,255,.62);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-0: #071225;
        --bg-1: #0f2238;
        --bg-2: #1a2f44;
        --text: #ebf3ff;
        --muted: #9db3cf;
        --panel: rgba(12, 21, 40, 0.74);
        --border: rgba(145, 183, 227, 0.33);
        --code-bg: #040b17;
        --code-text: #e4efff;
        --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1rem;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 12% 12%, rgba(87,196,223,.18), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 24px;
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(145%);
      -webkit-backdrop-filter: blur(20px) saturate(145%);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.25rem 1.5rem;
    }
    .prose-noema h1, .prose-noema h2, .prose-noema h3 {
      line-height: 1.25;
      margin-top: 1.25rem;
      margin-bottom: .65rem;
    }
    .prose-noema h1 { margin-top: .1rem; font-size: 1.8rem; }
    .prose-noema h2 { font-size: 1.35rem; }
    .prose-noema p {
      line-height: 1.85;
      color: var(--text);
      margin: .7rem 0;
    }
    .prose-noema ul, .prose-noema ol {
      margin: .7rem 0;
      padding-left: 1.4rem;
    }
    .prose-noema ul { list-style: disc; }
    .prose-noema ol { list-style: decimal; }
    .prose-noema li { margin: .28rem 0; line-height: 1.72; }
    .prose-noema a { color: inherit; text-underline-offset: 2px; }
    .prose-noema pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 12px;
      padding: 1rem;
      overflow: auto;
      border: 1px solid rgba(255,255,255,.12);
    }
    .prose-noema code {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .prose-noema img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <main>
<article class="prose-noema">
<h1 id="機械学習のためのsql">機械学習のためのSQL</h1>
<p>機械学習では、モデル選択より前にデータを正しく整形することが重要です。<br>
実務ではその整形の多くを SQL で行います。SQL で作った特徴量は再現しやすく、学習環境と本番環境の差も小さくできます。</p>
<p>このノートでは、ECサービスの行動データを題材に、SQL の基本操作から、リークを避けた特徴量テーブル作成までを一気通貫で確認します。</p>

<pre><code class="language-python">import sqlite3
from datetime import datetime, timedelta
from random import Random
from textwrap import dedent</code></pre>
<p>まずはメモリ上にデータベースを作り、<code>users</code>, <code>events</code>, <code>orders</code> の3テーブルを定義します。<br>
<code>events</code> は行動ログ、<code>orders</code> は購入履歴、<code>users</code> は属性情報です。</p>

<pre><code class="language-python">conn = sqlite3.connect(&quot;:memory:&quot;)
conn.row_factory = sqlite3.Row
cur = conn.cursor()

cur.executescript(
    dedent(
        &quot;&quot;&quot;
        CREATE TABLE users (
            user_id INTEGER PRIMARY KEY,
            signup_date TEXT NOT NULL,
            plan TEXT NOT NULL,
            country TEXT NOT NULL
        );

        CREATE TABLE events (
            event_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            event_time TEXT NOT NULL,
            event_type TEXT NOT NULL,
            session_seconds INTEGER NOT NULL,
            clicks INTEGER NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id)
        );

        CREATE TABLE orders (
            order_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            order_time TEXT NOT NULL,
            amount REAL NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id)
        );
        &quot;&quot;&quot;
    )
)
conn.commit()</code></pre>
<pre><code class="language-python">def q(sql: str, params=()):
    return conn.execute(dedent(sql), params).fetchall()


def show(rows, limit=8):
    rows = list(rows)
    if not rows:
        print(&quot;(no rows)&quot;)
        return
    cols = rows[0].keys()
    print(&quot; | &quot;.join(cols))
    print(&quot;-&quot; * 100)
    for r in rows[:limit]:
        print(&quot; | &quot;.join(str(r[c]) for c in cols))
    if len(rows) &gt; limit:
        print(f&quot;... ({len(rows)} rows total)&quot;)</code></pre>
<p>以降は次の2つの関数を使います。</p>
<ul>
<li><code>q(sql, params)</code>: SQLを実行して結果行を返す</li>
<li><code>show(rows)</code>: 結果を見やすく表示する</li>
</ul>
<p>例: <code>show(q(&quot;SELECT COUNT(*) AS n FROM users&quot;))</code></p>

<p>次に、分析用の疑似データを生成します。セルを3つに分けて、<br>
<code>ユーザー生成 → イベント生成 → 注文生成</code> の順で作ります。</p>

<pre><code class="language-python">rng = Random(42)
start = datetime(2024, 1, 1)
end = datetime(2024, 6, 30)

plans = [&quot;free&quot;, &quot;pro&quot;, &quot;team&quot;]
plan_weights = [0.62, 0.30, 0.08]
countries = [&quot;JP&quot;, &quot;US&quot;, &quot;IN&quot;, &quot;DE&quot;, &quot;FR&quot;]

n_users = 320
for user_id in range(1, n_users + 1):
    signup = start + timedelta(days=rng.randint(0, 80))
    plan = rng.choices(plans, weights=plan_weights, k=1)[0]
    country = rng.choice(countries)
    cur.execute(
        &quot;INSERT INTO users (user_id, signup_date, plan, country) VALUES (?, ?, ?, ?)&quot;,
        (user_id, signup.date().isoformat(), plan, country),
    )

conn.commit()</code></pre>
<pre><code class="language-python">for row in q(&quot;SELECT user_id, plan, signup_date FROM users&quot;):
    user_id = row[&quot;user_id&quot;]
    plan = row[&quot;plan&quot;]
    signup_dt = datetime.fromisoformat(row[&quot;signup_date&quot;])

    base_events = 20 if plan == &quot;free&quot; else 34 if plan == &quot;pro&quot; else 46
    n_events = max(8, int(rng.gauss(base_events, 6)))

    for _ in range(n_events):
        day_offset = rng.randint(0, 178)
        event_dt = signup_dt + timedelta(days=day_offset, hours=rng.randint(0, 23), minutes=rng.randint(0, 59))
        if event_dt &gt; end:
            continue

        if plan == &quot;free&quot;:
            clicks = max(0, int(rng.gauss(2.2, 1.4)))
            session_seconds = max(20, int(rng.gauss(130, 70)))
        elif plan == &quot;pro&quot;:
            clicks = max(0, int(rng.gauss(4.8, 2.0)))
            session_seconds = max(30, int(rng.gauss(220, 90)))
        else:
            clicks = max(0, int(rng.gauss(6.5, 2.4)))
            session_seconds = max(40, int(rng.gauss(290, 110)))

        event_type = rng.choices(
            [&quot;page_view&quot;, &quot;search&quot;, &quot;add_to_cart&quot;],
            weights=[0.62, 0.25, 0.13],
            k=1,
        )[0]

        cur.execute(
            &quot;&quot;&quot;
            INSERT INTO events (user_id, event_time, event_type, session_seconds, clicks)
            VALUES (?, ?, ?, ?, ?)
            &quot;&quot;&quot;,
            (user_id, event_dt.isoformat(sep=&quot; &quot;), event_type, session_seconds, clicks),
        )

conn.commit()</code></pre>
<pre><code class="language-python">activity = q(
    &quot;&quot;&quot;
    SELECT
        u.user_id,
        u.plan,
        u.signup_date,
        COALESCE(COUNT(e.event_id), 0) AS event_count,
        COALESCE(SUM(e.clicks), 0) AS total_clicks
    FROM users u
    LEFT JOIN events e ON u.user_id = e.user_id
    GROUP BY u.user_id, u.plan, u.signup_date
    &quot;&quot;&quot;
)

for r in activity:
    user_id = r[&quot;user_id&quot;]
    plan = r[&quot;plan&quot;]
    signup_dt = datetime.fromisoformat(r[&quot;signup_date&quot;])
    total_clicks = r[&quot;total_clicks&quot;]
    event_count = r[&quot;event_count&quot;]

    base_prob = 0.02
    if plan == &quot;pro&quot;:
        base_prob += 0.08
    if plan == &quot;team&quot;:
        base_prob += 0.12
    base_prob += min(0.35, total_clicks / 380.0)
    base_prob += min(0.20, event_count / 420.0)

    n_orders = 0
    for _ in range(3):
        if rng.random() &lt; base_prob:
            n_orders += 1

    min_order_dt = signup_dt + timedelta(days=1)
    max_order_dt = min(end, signup_dt + timedelta(days=180))
    if min_order_dt &gt; max_order_dt:
        continue

    total_seconds = int((max_order_dt - min_order_dt).total_seconds())

    for _ in range(n_orders):
        offset_sec = rng.randint(0, total_seconds)
        order_dt = min_order_dt + timedelta(seconds=offset_sec)

        mean_amount = 38 if plan == &quot;free&quot; else 74 if plan == &quot;pro&quot; else 130
        amount = max(8, round(rng.gauss(mean_amount, mean_amount * 0.35), 2))

        cur.execute(
            &quot;INSERT INTO orders (user_id, order_time, amount) VALUES (?, ?, ?)&quot;,
            (user_id, order_dt.isoformat(sep=&quot; &quot;), amount),
        )

conn.commit()</code></pre>
<pre><code class="language-python">table_counts = q(
    &quot;&quot;&quot;
    SELECT &#39;users&#39; AS table_name, COUNT(*) AS n FROM users
    UNION ALL
    SELECT &#39;events&#39; AS table_name, COUNT(*) AS n FROM events
    UNION ALL
    SELECT &#39;orders&#39; AS table_name, COUNT(*) AS n FROM orders
    &quot;&quot;&quot;
)
show(table_counts)</code></pre>
<p>ここから SQL の基本操作を確認します。<br>
まずは <code>WHERE</code> と <code>ORDER BY</code> で、特定ユーザーのイベント履歴を時系列に取得します。</p>

<pre><code class="language-python">rows = q(
    &quot;&quot;&quot;
    SELECT user_id, event_time, event_type, session_seconds, clicks
    FROM events
    WHERE user_id = ?
    ORDER BY event_time
    LIMIT 10
    &quot;&quot;&quot;,
    (12,),
)
show(rows)</code></pre>
<p>次に <code>GROUP BY</code> でユーザー単位の集計を作ります。<br>
この集計はそのまま特徴量の候補になります。</p>

<pre><code class="language-python">agg = q(
    &quot;&quot;&quot;
    SELECT
        user_id,
        COUNT(*) AS n_events,
        SUM(clicks) AS total_clicks,
        AVG(session_seconds) AS avg_session_seconds
    FROM events
    GROUP BY user_id
    HAVING COUNT(*) &gt;= 18
    ORDER BY total_clicks DESC
    LIMIT 10
    &quot;&quot;&quot;
)
show(agg)</code></pre>
<p><code>JOIN</code> と <code>CASE WHEN</code> を使うと、属性と行動を組み合わせた特徴量を作れます。<br>
この例では、ある時点（<code>asof_ts</code>）より前90日間の購入金額を集計し、プランを数値化します。</p>

<pre><code class="language-python">asof_ts = &#39;2024-05-01 00:00:00&#39;

joined = q(
    &quot;&quot;&quot;
    WITH spend_90 AS (
      SELECT
          user_id,
          SUM(amount) AS spend_90d
      FROM orders
      WHERE order_time &gt;= datetime(:asof_ts, &#39;-90 day&#39;)
        AND order_time &lt; :asof_ts
      GROUP BY user_id
    )
    SELECT
        u.user_id,
        u.plan,
        CASE WHEN u.plan = &#39;free&#39; THEN 0 ELSE 1 END AS paid_flag,
        COALESCE(s.spend_90d, 0) AS spend_90d
    FROM users u
    LEFT JOIN spend_90 s ON u.user_id = s.user_id
    ORDER BY spend_90d DESC
    LIMIT 12
    &quot;&quot;&quot;,
    {&quot;asof_ts&quot;: asof_ts},
)
show(joined)</code></pre>
<p>ここから機械学習用テーブルを作ります。</p>
<p>時点の定義:</p>
<ul>
<li><code>snapshot</code>: 予測時点</li>
<li>特徴量窓: <code>snapshot</code> より前30日</li>
<li>ラベル窓: <code>snapshot</code> 以上かつ <code>snapshot+30日</code> 未満</li>
</ul>

<pre><code class="language-python">snapshot = &#39;2024-05-01 00:00:00&#39;
horizon_days = 30

feature_sql = &quot;&quot;&quot;
WITH event_30d AS (
    SELECT
        user_id,
        COUNT(*) AS events_30d,
        SUM(clicks) AS clicks_30d,
        AVG(session_seconds) AS avg_session_30d,
        MAX(event_time) AS last_event_time
    FROM events
    WHERE event_time &lt; :snapshot
      AND event_time &gt;= datetime(:snapshot, &#39;-30 day&#39;)
    GROUP BY user_id
),
order_90d AS (
    SELECT
        user_id,
        SUM(amount) AS spend_90d
    FROM orders
    WHERE order_time &lt; :snapshot
      AND order_time &gt;= datetime(:snapshot, &#39;-90 day&#39;)
    GROUP BY user_id
),
label_window AS (
    SELECT
        user_id,
        CASE WHEN COUNT(*) &gt; 0 THEN 1 ELSE 0 END AS purchased_30d
    FROM orders
    WHERE order_time &gt;= :snapshot
      AND order_time &lt; datetime(:snapshot, &#39;+&#39; || :horizon_days || &#39; day&#39;)
    GROUP BY user_id
)
SELECT
    u.user_id,
    u.country,
    CASE WHEN u.plan = &#39;free&#39; THEN 0 ELSE 1 END AS paid_flag,
    COALESCE(e.events_30d, 0) AS events_30d,
    COALESCE(e.clicks_30d, 0) AS clicks_30d,
    COALESCE(e.avg_session_30d, 0) AS avg_session_30d,
    -- イベントがないユーザーは signup_date を最終行動日として扱う
    CAST((julianday(:snapshot) - julianday(COALESCE(e.last_event_time, u.signup_date))) AS INTEGER) AS days_since_last_event,
    COALESCE(o.spend_90d, 0) AS spend_90d,
    COALESCE(l.purchased_30d, 0) AS label
FROM users u
LEFT JOIN event_30d e ON u.user_id = e.user_id
LEFT JOIN order_90d o ON u.user_id = o.user_id
LEFT JOIN label_window l ON u.user_id = l.user_id
ORDER BY u.user_id
&quot;&quot;&quot;</code></pre>
<pre><code class="language-python">feature_rows = q(feature_sql, {&quot;snapshot&quot;: snapshot, &quot;horizon_days&quot;: horizon_days})
show(feature_rows, limit=12)
print(&#39;rows:&#39;, len(feature_rows))</code></pre>
<pre><code class="language-python">label_dist_sql = f&quot;&quot;&quot;
WITH base AS (
{feature_sql}
)
SELECT
    label,
    COUNT(*) AS n_users,
    ROUND(AVG(events_30d), 2) AS avg_events_30d,
    ROUND(AVG(spend_90d), 2) AS avg_spend_90d
FROM base
GROUP BY label
ORDER BY label
&quot;&quot;&quot;

label_dist = q(label_dist_sql, {&quot;snapshot&quot;: snapshot, &quot;horizon_days&quot;: horizon_days})
show(label_dist)</code></pre>
<p>次に、リークの例を確認します。<br>
比較を明確にするため、窓幅はどちらも30日に固定し、未来を含むかどうかだけを変えます。</p>

<pre><code class="language-python">clean_stats_sql = f&quot;&quot;&quot;
WITH base AS (
{feature_sql}
)
SELECT label, ROUND(AVG(events_30d), 2) AS avg_events
FROM base
GROUP BY label
ORDER BY label
&quot;&quot;&quot;

leaky_stats_sql = &quot;&quot;&quot;
WITH event_30d_leaky AS (
    SELECT
        user_id,
        COUNT(*) AS events_30d
    FROM events
    WHERE event_time &gt;= :snapshot
      -- NG: snapshot以降（未来）のイベントを特徴量に含める
      AND event_time &lt; datetime(:snapshot, &#39;+&#39; || :horizon_days || &#39; day&#39;)
    GROUP BY user_id
),
label_window AS (
    SELECT
        user_id,
        CASE WHEN COUNT(*) &gt; 0 THEN 1 ELSE 0 END AS label
    FROM orders
    WHERE order_time &gt;= :snapshot
      AND order_time &lt; datetime(:snapshot, &#39;+&#39; || :horizon_days || &#39; day&#39;)
    GROUP BY user_id
)
SELECT
    COALESCE(l.label, 0) AS label,
    ROUND(AVG(COALESCE(e.events_30d, 0)), 2) AS avg_events
FROM users u
LEFT JOIN event_30d_leaky e ON u.user_id = e.user_id
LEFT JOIN label_window l ON u.user_id = l.user_id
GROUP BY COALESCE(l.label, 0)
ORDER BY label
&quot;&quot;&quot;

clean_stats = q(clean_stats_sql, {&quot;snapshot&quot;: snapshot, &quot;horizon_days&quot;: horizon_days})
leaky_stats = q(leaky_stats_sql, {&quot;snapshot&quot;: snapshot, &quot;horizon_days&quot;: horizon_days})

print(&#39;clean feature mean by label&#39;)
show(clean_stats)
print(&#39;leaky feature mean by label&#39;)
show(leaky_stats)</code></pre>
<p>最後に、学習用テーブルを分割できる形へ整えます。<br>
<code>%</code> は余り演算子で、<code>x % 5</code> は 0〜4 の fold 番号を作ります。<br>
ここでは分かりやすさ優先で <code>user_id % 5</code> を使います（実務ではハッシュ関数を使うことが多いです）。</p>

<pre><code class="language-python">dataset_fold_sql = f&quot;&quot;&quot;
WITH base AS (
{feature_sql}
)
SELECT
    user_id,
    paid_flag,
    events_30d,
    clicks_30d,
    avg_session_30d,
    days_since_last_event,
    spend_90d,
    label,
    (user_id % 5) AS fold_id
FROM base
ORDER BY user_id
&quot;&quot;&quot;

dataset_with_fold = q(dataset_fold_sql, {&quot;snapshot&quot;: snapshot, &quot;horizon_days&quot;: horizon_days})
show(dataset_with_fold, limit=12)</code></pre>
<p>SQL は機械学習パイプラインの前工程ではなく、学習品質を決める中核です。<br>
特に重要なのは、ラベル時点と特徴量時点の境界を明示し、未来情報を混ぜないことです。</p>
<p>モデルを変える前に、SQL で作る学習テーブルが「本番時点でも再現可能か」を必ず確認してください。</p>

</article>
  </main>
  <script src="/highlight/highlight.min.js"></script>
  <script>
    (function () {
      if (!window.hljs) return;
      document.querySelectorAll("pre code").forEach(function (block) {
        window.hljs.highlightElement(block);
      });
    })();
  </script>
</body>
</html>