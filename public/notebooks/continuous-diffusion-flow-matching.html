<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>continuous-diffusion-flow-matching</title>
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <style>
    :root {
      --bg-0: #f3f8fb;
      --bg-1: #d7e8f4;
      --bg-2: #f9f1e7;
      --text: #09162b;
      --muted: #44556f;
      --panel: rgba(255,255,255,.72);
      --border: rgba(255,255,255,.62);
      --code-bg: #09131a;
      --code-text: #e6f0f5;
      --shadow: 0 24px 54px rgba(10, 26, 54, 0.18), inset 0 1px 0 rgba(255,255,255,.62);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-0: #071225;
        --bg-1: #0f2238;
        --bg-2: #1a2f44;
        --text: #ebf3ff;
        --muted: #9db3cf;
        --panel: rgba(12, 21, 40, 0.74);
        --border: rgba(145, 183, 227, 0.33);
        --code-bg: #040b17;
        --code-text: #e4efff;
        --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1rem;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background:
        radial-gradient(circle at 12% 12%, rgba(87,196,223,.18), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 24px;
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(145%);
      -webkit-backdrop-filter: blur(20px) saturate(145%);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.25rem 1.5rem;
    }
    .prose-noema h1, .prose-noema h2, .prose-noema h3 {
      line-height: 1.25;
      margin-top: 1.25rem;
      margin-bottom: .65rem;
    }
    .prose-noema h1 { margin-top: .1rem; font-size: 1.8rem; }
    .prose-noema h2 { font-size: 1.35rem; }
    .prose-noema p {
      line-height: 1.85;
      color: var(--text);
      margin: .7rem 0;
    }
    .prose-noema a { color: inherit; text-underline-offset: 2px; }
    .prose-noema pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 12px;
      padding: 1rem;
      overflow: auto;
      border: 1px solid rgba(255,255,255,.12);
    }
    .prose-noema code {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .prose-noema img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <main>
<article class="prose-noema">
<h1 id="連続時間拡散モデルとフローマッチング理論">連続時間拡散モデルとフローマッチング理論</h1>
<p>連続時間拡散モデルとフローマッチング理論を、初学者が「概念 -&gt; 理論 -&gt; 実装」の順に理解できるように整理します。</p>
<h2 id="学習目標">学習目標</h2>
<p>- このテーマの中心概念を説明できる<br>- 最低限の数式/アルゴリズムの意味を追える<br>- 実装例を実行し、出力を解釈できる</p>
<h2 id="前提知識">前提知識</h2>
<p>- 必須: Python基礎（変数・関数・リスト/辞書）<br>- 推奨: 線形代数・確率統計の初歩<br>- 目安: 数式の各記号を言葉に置き換えられること</p>
<h2 id="直感">直感</h2>
<p>一言で言うと: 連続時間拡散モデルとフローマッチング理論は、複雑な対象を分解し、計算可能な形に落とし込む技術です。<br>理論を読む前に、まず『何を入力して何を出したいか』を図で考えると理解が速くなります。</p>
<h2 id="理論">理論</h2>
<p>- 連続時間拡散モデルとフローマッチング理論で扱う主要な前提・仮定を明確にする。<br>- 評価指標または目的関数を明確にし、何を最適化するかを定義する。<br>- 実装時にはデータ前処理と境界条件の扱いが結果を大きく左右する。<br>- 連続時間拡散はSDE/ODEで生成過程を定式化する。<br>- Flow Matchingは速度場学習で確率輸送を近似する。</p>
<h3 id="代表式">代表式</h3>
<p>- $p_\theta(x)=\int p_\theta(x|z)p(z)dz$<br>- $\nabla_x \log p(x)$</p>
<h2 id="実装の流れ">実装の流れ</h2>
<p>1. 最小の入力データを準備し、入出力の型・次元を確認する。<br>2. 理論式に対応する計算を小さなコードで再現する。<br>3. 中間値を可視化/出力して、期待と一致しているか検証する。<br>4. 条件を変えたときの挙動を比較し、感度を確認する。</p>
<pre><code class="language-python">import random
random.seed(7)
latent = [random.gauss(0, 1) for _ in range(3)]
decoded = [round(2 * z + 1, 3) for z in latent]
print(&#39;latent :&#39;, latent)
print(&#39;decoded:&#39;, decoded)</code></pre>
<h2 id="よくあるつまずき">よくあるつまずき</h2>
<p>- 式やアルゴリズムを暗記だけで進め、前提条件を見落とす。<br>- データのスケール・欠損・外れ値を確認せずに学習/推論を行う。<br>- 評価指標を1つだけ見て結論を急ぎ、失敗ケース分析を省略する。</p>
<h2 id="演習">演習</h2>
<p>1. ノートのコードを一部書き換えて、出力がどう変化するか説明する。<br>2. 理論式の各項が何を意味するか、自分の言葉で1行ずつ説明する。<br>3. 実運用を想定し、入力異常（欠損・外れ値・分布ずれ）への対処案を3つ挙げる。</p>
<h2 id="まとめ">まとめ</h2>
<p>連続時間拡散モデルとフローマッチング理論で章末テーマまで到達しました。ここまでのノートを横断して復習すると理解が安定します。<br>次は関連ノートに進み、同じ観点で比較してください。</p>
</article>
  </main>
  <script src="/highlight/highlight.min.js"></script>
  <script>
    (function () {
      if (!window.hljs) return;
      document.querySelectorAll("pre code").forEach(function (block) {
        window.hljs.highlightElement(block);
      });
    })();
  </script>
</body>
</html>