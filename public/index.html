<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noema</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="/highlight/atom-one-dark.min.css" />
  <link rel="stylesheet" href="/katex/katex.min.css" />
  <style>
    :root {
      --bg-0: #071225;
      --bg-1: #0f2238;
      --bg-2: #1a2f44;
      --text: #ebf3ff;
      --muted: #9db3cf;
      --panel: rgba(10, 18, 33, 0.52);
      --panel-strong: rgba(12, 21, 40, 0.74);
      --panel-soft: rgba(12, 23, 43, 0.36);
      --border: rgba(145, 183, 227, 0.33);
      --accent: #71aabd;
      --accent-strong: #5b8ea2;
      --input-bg: rgba(21,34,56,.66);
      --shadow: 0 30px 66px rgba(2, 7, 16, 0.58), inset 0 1px 0 rgba(166,205,255,.16);
      --glass-edge: rgba(148, 189, 234, .34);
      --glass-edge-soft: rgba(148, 189, 234, .2);
      --glass-highlight: rgba(198, 223, 255, .16);
      --glass-shadow: 0 24px 44px rgba(3, 8, 17, .42);
      --code-bg: #282c34;
      --code-fg: #d8e8ff;
      --code-border: rgba(116, 171, 232, .26);
      --brand-font: "Space Grotesk", "Avenir Next", "SF Pro Display", "Helvetica Neue", sans-serif;
      --assistant-width: 400px;
      color-scheme: dark;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      position: relative;
      background:
        radial-gradient(circle at 12% 12%, color-mix(in oklab, var(--accent) 20%, transparent), transparent 44%),
        radial-gradient(circle at 88% 5%, rgba(255, 155, 96, 0.16), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(109, 196, 255, 0.2), transparent 45%),
        linear-gradient(155deg, var(--bg-0) 0%, var(--bg-1) 48%, var(--bg-2) 100%);
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    body::before {
      background:
        radial-gradient(circle at 20% 22%, rgba(255, 255, 255, .16), transparent 34%),
        radial-gradient(circle at 82% 18%, rgba(127, 206, 255, .15), transparent 36%);
      filter: blur(22px);
      opacity: .85;
    }

    body::after {
      background:
        linear-gradient(160deg, rgba(255,255,255,.08), transparent 36%),
        linear-gradient(332deg, rgba(255,255,255,.04), transparent 44%);
    }

    a { color: inherit; text-decoration: none; }

    .glass-strong {
      background:
        linear-gradient(145deg, color-mix(in oklab, var(--glass-highlight) 66%, transparent), transparent 42%),
        linear-gradient(328deg, color-mix(in oklab, var(--panel-strong) 88%, transparent), color-mix(in oklab, var(--panel) 76%, transparent));
      border: 1px solid var(--glass-edge);
      backdrop-filter: blur(22px) saturate(155%);
      -webkit-backdrop-filter: blur(22px) saturate(155%);
      box-shadow:
        var(--glass-shadow),
        inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 88%, transparent),
        inset 0 -1px 0 color-mix(in oklab, var(--glass-edge-soft) 70%, transparent);
    }

    .glass-soft {
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--glass-highlight) 54%, transparent), transparent 52%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
      border: 1px solid var(--glass-edge-soft);
      backdrop-filter: blur(16px) saturate(140%);
      -webkit-backdrop-filter: blur(16px) saturate(140%);
      box-shadow:
        0 8px 18px color-mix(in oklab, var(--shadow) 28%, transparent),
        inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 72%, transparent);
    }

    .button {
      border: 1px solid color-mix(in oklab, var(--accent) 52%, white);
      color: color-mix(in oklab, #f7fbff 88%, var(--text));
      background:
        linear-gradient(
          145deg,
          color-mix(in oklab, var(--accent) 58%, var(--panel-strong)) 0%,
          color-mix(in oklab, var(--accent-strong) 62%, var(--panel-soft)) 100%
        );
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      box-shadow:
        0 10px 22px color-mix(in oklab, var(--accent) 18%, transparent),
        inset 0 1px 0 rgba(255,255,255,.26);
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }

    .button-ghost {
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(155deg, color-mix(in oklab, var(--glass-highlight) 58%, transparent), transparent 60%),
        color-mix(in oklab, var(--panel-soft) 92%, transparent);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      box-shadow:
        inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 70%, transparent),
        0 6px 14px color-mix(in oklab, var(--shadow) 26%, transparent);
    }

    /* Liquid Glass Navigation */
    .liquid-glass-navigation {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }

    .liquid-nav {
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 40%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 82%, transparent);
      backdrop-filter: blur(18px) saturate(1.55);
      -webkit-backdrop-filter: blur(18px) saturate(1.55);
      border: 1px solid var(--glass-edge-soft);
      border-radius: 50px;
      padding: 8px;
      display: flex;
      gap: 4px;
      width: max-content;
      box-shadow:
        inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 82%, transparent),
        0 16px 30px color-mix(in oklab, var(--shadow) 34%, transparent);
    }

    .nav-item {
      padding: 8px 16px;
      border-radius: 50px;
      color: color-mix(in oklab, var(--text) 88%, white);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      border: 0;
      background: transparent;
      cursor: pointer;
      line-height: 1.1;
      font-family: inherit;
    }

    .nav-item:hover {
      background: color-mix(in oklab, var(--panel-strong) 88%, transparent);
      transform: translateY(-1px);
    }

    .nav-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: color-mix(in oklab, var(--glass-highlight) 72%, transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .nav-item:hover::before {
      opacity: 1;
    }

    .layout {
      height: 100dvh;
      max-width: 1900px;
      margin: 0 auto;
      padding: 10px;
      position: relative;
      z-index: 1;
    }

    .shell {
      height: 100%;
      display: grid;
      grid-template-columns: 300px minmax(0, 1fr) auto auto;
      gap: 10px;
      position: relative;
      z-index: 1;
    }

    .sidebar {
      border-radius: 24px;
      padding: 12px;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sidebar h1 {
      font-family: var(--brand-font);
      font-size: 28px;
      font-weight: 700;
      letter-spacing: .14em;
      text-transform: uppercase;
      margin: 8px 8px 4px;
      line-height: 1.15;
      color: var(--text);
      text-shadow: 0 8px 20px color-mix(in oklab, var(--accent) 24%, transparent);
    }

    .brand-link {
      display: inline-block;
      text-decoration: none;
      color: inherit;
      border-radius: 10px;
      padding: 2px 4px;
      outline: none;
    }

    .brand-link:focus-visible {
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 28%, transparent);
    }

    @supports ((background-clip: text) or (-webkit-background-clip: text)) {
      .sidebar h1 {
        background: linear-gradient(
          135deg,
          color-mix(in oklab, var(--accent) 78%, white) 0%,
          color-mix(in oklab, var(--text) 72%, var(--accent)) 60%,
          color-mix(in oklab, var(--accent-strong) 66%, var(--text)) 100%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
    }

    .search {
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(145deg, color-mix(in oklab, var(--glass-highlight) 46%, transparent), transparent 56%),
        var(--input-bg);
      border-radius: 12px;
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      margin: 0 4px;
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 70%, transparent);
    }

    .search input {
      border: 0;
      outline: 0;
      background: transparent;
      color: var(--text);
      font-size: 14px;
      width: 100%;
    }

    #sidebar-list,
    #sidebar-mobile-list {
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      display: block;
      padding-right: 4px;
      overscroll-behavior: contain;
      scrollbar-gutter: stable both-edges;
    }

    .chapter {
      flex: 0 0 auto;
      border-radius: 14px;
      overflow: hidden;
    }

    .chapter + .chapter {
      margin-top: 8px;
    }

    .chapter-toggle {
      width: 100%;
      border: 1px solid color-mix(in oklab, var(--glass-edge-soft) 76%, transparent);
      background:
        linear-gradient(152deg, color-mix(in oklab, var(--glass-highlight) 44%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 72%, transparent);
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 10px 10px 12px;
      font-weight: 650;
      cursor: pointer;
      font-size: 13px;
      text-align: left;
      border-radius: 11px;
      transition: background 180ms ease, border-color 180ms ease, box-shadow 180ms ease;
      backdrop-filter: blur(16px) saturate(140%);
      -webkit-backdrop-filter: blur(16px) saturate(140%);
    }

    .chapter-toggle:hover {
      background: color-mix(in oklab, var(--panel-strong) 85%, transparent);
      border-color: color-mix(in oklab, var(--accent) 28%, var(--border));
    }

    .chapter-toggle:focus-visible {
      outline: none;
      border-color: color-mix(in oklab, var(--accent) 65%, white);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 24%, transparent);
    }

    .chapter-toggle[aria-expanded="true"] {
      background: color-mix(in oklab, var(--panel-strong) 96%, transparent);
      border-color: color-mix(in oklab, var(--accent) 26%, var(--border));
    }

    .chapter-title {
      font-weight: 700;
      letter-spacing: .01em;
    }

    .chapter-arrow {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 8px;
      border: 1px solid color-mix(in oklab, var(--accent) 22%, var(--border));
      background:
        radial-gradient(circle at 30% 28%, color-mix(in oklab, var(--panel-strong) 78%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-soft) 68%, transparent);
      color: color-mix(in oklab, var(--accent) 62%, var(--text));
      transition:
        transform 180ms ease,
        color 180ms ease,
        background 180ms ease,
        border-color 180ms ease;
    }

    .chapter-arrow svg {
      width: 11px;
      height: 11px;
      display: block;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .chapter-arrow.expanded {
      transform: rotate(90deg);
      color: #fff;
      border-color: color-mix(in oklab, var(--accent) 66%, white);
      background: linear-gradient(145deg, var(--accent) 0%, var(--accent-strong) 100%);
    }

    .chapter-items {
      border-top: 1px solid var(--glass-edge-soft);
      padding: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: min(44vh, 420px);
      overflow-y: auto;
      overflow-x: hidden;
      overscroll-behavior: contain;
      scrollbar-gutter: stable;
      background: color-mix(in oklab, var(--panel-soft) 48%, transparent);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .nb-item {
      border: 1px solid transparent;
      border-radius: 10px;
      background: color-mix(in oklab, var(--panel-soft) 46%, transparent);
      text-align: left;
      color: var(--muted);
      padding: 8px 10px;
      cursor: pointer;
      font-size: 13px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 56%, transparent);
    }

    .nb-item:hover {
      background: color-mix(in oklab, var(--panel-strong) 88%, transparent);
      border-color: color-mix(in oklab, var(--glass-edge-soft) 74%, transparent);
      color: var(--text);
    }
    .nb-item.active {
      color: #fff;
      border-color: color-mix(in oklab, var(--accent) 68%, white);
      background: linear-gradient(145deg, color-mix(in oklab, var(--accent) 80%, white), color-mix(in oklab, var(--accent-strong) 88%, black));
      box-shadow: 0 10px 20px color-mix(in oklab, var(--accent) 30%, transparent);
    }

    .sidebar-footer {
      border-top: 1px solid var(--border);
      padding: 10px 8px 6px;
      margin-top: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-footer .button:not(.is-hidden),
    .sidebar-footer .button-ghost:not(.is-hidden) {
      display: block;
      width: 100%;
      text-align: center;
    }

    .footer-link:not(.is-hidden) {
      display: block;
      text-align: center;
    }

    .main {
      min-width: 0;
      border-radius: 24px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .header {
      position: sticky;
      top: 0;
      z-index: 10;
      border-bottom: 1px solid var(--glass-edge-soft);
      padding: 10px 14px;
      background:
        linear-gradient(180deg, color-mix(in oklab, var(--glass-highlight) 28%, transparent), transparent 42%),
        color-mix(in srgb, var(--panel-strong) 90%, transparent);
      backdrop-filter: blur(18px) saturate(150%);
      -webkit-backdrop-filter: blur(18px) saturate(150%);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 54%, transparent);
    }

    .header-top {
      display: grid;
      grid-template-columns: 1fr minmax(0, auto) 1fr;
      align-items: center;
      gap: 12px;
    }

    .header-spacer {
      min-width: 0;
    }

    .header-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .header-title-select {
      min-width: min(58vw, 560px);
      max-width: min(58vw, 560px);
      border: 1px solid var(--glass-edge-soft);
      border-radius: 999px;
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 34%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-soft) 80%, transparent);
      color: var(--text);
      font-size: 14px;
      font-weight: 700;
      letter-spacing: .01em;
      padding: 7px 12px;
      outline: none;
      cursor: pointer;
      text-align: center;
      text-overflow: ellipsis;
    }

    .header-title-select:focus-visible {
      box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 28%, transparent);
    }

    .header-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    #reader {
      min-height: 0;
      overflow: auto;
      padding: 12px;
      background:
        linear-gradient(180deg, color-mix(in oklab, var(--glass-highlight) 18%, transparent), transparent 56%);
    }

    .selection-card {
      margin: 0 auto 10px;
      max-width: 980px;
      padding: 10px;
      border-radius: 12px;
      display: none;
      justify-content: space-between;
      gap: 8px;
      align-items: flex-start;
      font-size: 13px;
      background:
        linear-gradient(145deg, color-mix(in oklab, var(--glass-highlight) 48%, transparent), transparent 60%),
        color-mix(in oklab, var(--panel-soft) 84%, transparent);
      border: 1px solid var(--glass-edge-soft);
      backdrop-filter: blur(16px) saturate(138%);
      -webkit-backdrop-filter: blur(16px) saturate(138%);
    }

    .selection-title { font-weight: 700; margin-bottom: 4px; }
    .selection-text { color: var(--muted); max-height: 48px; overflow: hidden; white-space: pre-wrap; }

    #reader-card {
      max-width: 980px;
      margin: 0 auto;
      border-radius: 16px;
      padding: 16px 18px;
      background: transparent;
      border: 0;
      box-shadow: none;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
    }

    .reader-prose h1,
    .reader-prose h2,
    .reader-prose h3 { line-height: 1.25; margin-top: 1.4em; margin-bottom: .6em; }
    .reader-prose h1 { margin-top: .2em; font-size: 2rem; }
    .reader-prose h2 { font-size: 1.5rem; }
    .reader-prose p { line-height: 1.85; }
    .reader-prose pre {
      background: var(--code-bg);
      color: var(--code-fg);
      font-family: "JetBrains Mono", "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.58;
      border: 1px solid var(--code-border);
      border-radius: 12px;
      padding: 12px;
      overflow: visible;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.12);
    }

    .home-stage {
      display: grid;
      gap: 12px;
      margin-bottom: 14px;
    }

    .home-hero-shell {
      border-radius: 18px;
      padding: 16px;
      border: 1px solid var(--glass-edge-soft);
      background:
        radial-gradient(circle at 8% 10%, color-mix(in oklab, var(--glass-highlight) 68%, transparent), transparent 34%),
        radial-gradient(circle at 86% 12%, color-mix(in oklab, var(--accent) 26%, transparent), transparent 38%),
        linear-gradient(150deg, color-mix(in oklab, var(--panel-soft) 82%, transparent), color-mix(in oklab, var(--panel-strong) 64%, transparent));
      backdrop-filter: blur(18px) saturate(145%);
      -webkit-backdrop-filter: blur(18px) saturate(145%);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 62%, transparent);
    }

    .home-hero-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 12px;
    }

    .home-kicker {
      margin: 0 0 6px;
      font-size: 11px;
      color: color-mix(in oklab, var(--muted) 86%, white);
      letter-spacing: .14em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .home-title {
      margin: 0 0 8px;
      font-family: var(--brand-font);
      font-size: 34px;
      line-height: 1.05;
      letter-spacing: .02em;
      text-transform: uppercase;
    }

    .home-lead {
      margin: 0;
      color: var(--muted);
      line-height: 1.78;
      font-size: 14px;
      max-width: 64ch;
    }

    .home-orbit {
      position: relative;
      width: 92px;
      height: 92px;
      flex: 0 0 92px;
      border-radius: 999px;
      border: 1px solid color-mix(in oklab, var(--accent) 30%, var(--glass-edge-soft));
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.24), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 88%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 70%, transparent);
    }

    .home-orbit span {
      position: absolute;
      border-radius: 999px;
      border: 1px dashed color-mix(in oklab, var(--glass-edge-soft) 82%, transparent);
      inset: 10px;
      animation: orbit-spin 11s linear infinite;
    }

    .home-orbit span:nth-child(2) {
      inset: 22px;
      animation-duration: 8s;
      animation-direction: reverse;
    }

    .home-orbit span:nth-child(3) {
      inset: 34px;
      animation-duration: 6s;
    }

    @keyframes orbit-spin {
      to { transform: rotate(360deg); }
    }

    .home-metrics {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }

    .home-metric {
      border-radius: 12px;
      border: 1px solid var(--glass-edge-soft);
      padding: 10px 12px;
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      column-gap: 10px;
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 46%, transparent), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 86%, transparent);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .home-metric-label {
      display: inline-flex;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .03em;
      text-transform: uppercase;
      min-width: 0;
    }

    .home-metric-value {
      display: inline-flex;
      justify-self: end;
      text-align: right;
      font-size: clamp(28px, 2.35vw, 38px);
      line-height: 1;
      font-weight: 800;
      letter-spacing: .005em;
      color: color-mix(in oklab, var(--text) 88%, white);
      text-shadow: 0 8px 18px color-mix(in oklab, var(--accent) 28%, transparent);
    }

    .home-metric-value-status {
      font-size: clamp(13px, 1.05vw, 16px);
      line-height: 1.25;
      font-weight: 700;
      letter-spacing: .015em;
      text-shadow: none;
      max-width: 14ch;
      white-space: normal;
      text-wrap: balance;
    }

    .home-cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .home-cta,
    .home-cta-ghost {
      min-width: 170px;
    }

    .home-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    .home-card {
      border-radius: 14px;
      padding: 12px;
      font-size: 13px;
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--glass-highlight) 56%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 84%, transparent);
      border: 1px solid var(--glass-edge-soft);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      display: grid;
      gap: 8px;
    }

    .home-card-head {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .home-card-icon {
      width: 22px;
      height: 22px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid color-mix(in oklab, var(--accent) 30%, var(--glass-edge-soft));
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--accent) 26%, transparent), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 64%, transparent);
      color: color-mix(in oklab, var(--text) 86%, white);
      font-size: 11px;
      font-weight: 700;
    }

    .home-card strong {
      font-size: 14px;
      line-height: 1.35;
      letter-spacing: .01em;
    }

    .home-card p {
      margin: 0;
      color: var(--muted);
      line-height: 1.72;
    }

    .code-runner {
      margin: 1em 0;
      border: 1px solid var(--glass-edge-soft);
      border-radius: 12px;
      overflow: hidden;
      background: var(--code-bg);
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
    }

    .code-runner-shell {
      display: grid;
      grid-template-columns: 40px minmax(0, 1fr);
      align-items: stretch;
      background: var(--code-bg);
    }

    .code-runner-rail {
      border-right: 0;
      background:
        radial-gradient(
          circle at 50% 22px,
          color-mix(in oklab, var(--panel-strong) 40%, transparent) 0 18px,
          transparent 20px
        );
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 8px;
    }

    .code-runner pre {
      margin: 0;
      border-radius: 0;
      border: 0;
      background: var(--code-bg);
      color: var(--code-fg);
      font-family: "JetBrains Mono", "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.58;
      overflow: visible;
    }

    .code-editor-surface {
      position: relative;
      min-width: 0;
      display: grid;
      align-items: start;
      isolation: isolate;
      background: var(--code-bg);
      overflow: hidden;
    }

    .code-editor-surface pre {
      pointer-events: auto;
      position: relative;
      z-index: 1;
      opacity: 1 !important;
      visibility: visible !important;
    }

    .code-editor-surface pre,
    .code-editor-surface .code-editor {
      grid-area: 1 / 1;
      min-width: 0;
    }

    .code-editor {
      display: none;
      position: absolute;
      inset: 0;
      width: 100%;
      min-height: 100%;
      border: 0;
      border-radius: 0;
      margin: 0;
      padding: 12px;
      font-family: "JetBrains Mono", "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.58;
      resize: none;
      color: transparent;
      caret-color: var(--code-fg);
      background: transparent !important;
      outline: none;
      tab-size: 2;
      white-space: pre-wrap;
      overflow: hidden;
      overflow-wrap: break-word;
      z-index: 3;
      pointer-events: auto;
      -webkit-appearance: none;
      appearance: none;
      box-shadow: none;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }

    .reader-prose pre code,
    .code-runner pre code,
    #notebook-content .hljs {
      background: transparent !important;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      word-break: normal;
    }

    /* Keep highlighted code metrics identical to textarea overlay in playground mode. */
    #notebook-content .hljs {
      padding: 0 !important;
      margin: 0 !important;
      border: 0;
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      line-height: inherit;
      font: inherit;
      tab-size: 2;
    }

    .code-runner.playground-active .code-editor {
      display: block;
    }

    .code-runner.playground-active .code-editor-surface pre {
      pointer-events: none;
    }

    .code-runner.playground-active .code-runner-shell {
      align-items: start;
    }

    .run-code {
      width: 28px;
      height: 28px;
      border: 1px solid color-mix(in oklab, var(--accent) 28%, var(--border));
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 42%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-soft) 84%, transparent);
      color: var(--text);
      border-radius: 999px;
      padding: 0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 140ms ease, border-color 140ms ease, color 140ms ease;
    }

    .run-code:hover {
      background: color-mix(in oklab, var(--panel-strong) 94%, transparent);
      border-color: color-mix(in oklab, var(--accent) 48%, var(--border));
    }

    .run-code:disabled {
      cursor: wait;
      opacity: .85;
    }

    .run-code .run-icon {
      width: 12px;
      height: 12px;
      display: block;
      fill: currentColor;
      transform: translateX(1px);
    }

    .run-code .run-done-icon,
    .run-code .run-fail-icon {
      width: 12px;
      height: 12px;
      display: none;
      fill: none;
      stroke: currentColor;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .run-code.is-running .run-icon {
      display: none;
    }

    .run-code .run-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid color-mix(in oklab, var(--accent) 35%, transparent);
      border-top-color: currentColor;
      border-radius: 999px;
      display: none;
      animation: spin .8s linear infinite;
    }

    .run-code.is-running .run-spinner {
      display: block;
    }

    .run-code.is-done {
      color: color-mix(in oklab, #7fe0a9 82%, var(--text));
      border-color: color-mix(in oklab, #7fe0a9 52%, var(--border));
      background:
        linear-gradient(148deg, color-mix(in oklab, #7fe0a9 22%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
    }

    .run-code.is-done .run-icon {
      display: none;
    }

    .run-code.is-done .run-done-icon {
      display: block;
      transform: translateY(-.2px);
    }

    .run-code.is-failed {
      color: color-mix(in oklab, #ff9ea8 82%, var(--text));
      border-color: color-mix(in oklab, #ff9ea8 56%, var(--border));
      background:
        linear-gradient(148deg, color-mix(in oklab, #ff9ea8 20%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
    }

    .run-code.is-failed .run-icon {
      display: none;
    }

    .run-code.is-failed .run-fail-icon {
      display: block;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .code-output {
      margin: 0;
      padding: 9px 10px;
      border-top: 1px solid var(--border);
      font-size: 12px;
      white-space: pre-wrap;
      color: var(--text);
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--glass-highlight) 32%, transparent), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
      display: none;
    }

    .code-output.visible { display: block; }

    .resizer {
      width: 8px;
      border-radius: 8px;
      background:
        linear-gradient(180deg, color-mix(in oklab, var(--glass-highlight) 44%, transparent), color-mix(in oklab, var(--panel-soft) 74%, transparent));
      border: 1px solid var(--glass-edge-soft);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      cursor: col-resize;
      display: none;
    }

    .resizer.visible { display: block; }

    .assistant {
      width: var(--assistant-width);
      min-width: 320px;
      max-width: 700px;
      border-radius: 26px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .assistant.hidden { display: none; }

    .assistant-head {
      border: 1px solid var(--glass-edge-soft);
      border-radius: 16px;
      padding: 10px;
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 52%, transparent), transparent 56%),
        color-mix(in oklab, var(--panel-soft) 86%, transparent);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .assistant-head-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .assistant-title {
      font-weight: 700;
      font-size: 22px;
      margin: 0;
      letter-spacing: .01em;
    }

    .assistant-subtitle {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    #chat-log {
      min-height: 0;
      flex: 1;
      overflow: auto;
      border-radius: 16px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 42%, transparent), transparent 60%),
        color-mix(in oklab, var(--panel-soft) 84%, transparent);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
    }

    #chat-log::before {
      content: "";
      position: sticky;
      top: 0;
      display: block;
      height: 1px;
      width: 100%;
    }

    .msg-wrap {
      display: flex;
      align-items: flex-end;
      gap: 8px;
    }

    .msg-wrap.user {
      justify-content: flex-end;
    }

    .msg-avatar {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      flex: 0 0 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      color: color-mix(in oklab, var(--text) 84%, white);
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--glass-highlight) 46%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 88%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 62%, transparent);
      user-select: none;
    }

    .msg-wrap.user .msg-avatar {
      order: 2;
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--accent) 34%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 88%, transparent);
      border-color: color-mix(in oklab, var(--accent) 30%, var(--glass-edge-soft));
    }

    .msg-wrap.system .msg-avatar {
      display: none;
    }

    .msg {
      border-radius: 14px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.7;
      white-space: normal;
      max-width: min(90%, 520px);
    }

    .msg.user {
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--accent) 28%, transparent), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 90%, transparent);
      border-color: color-mix(in oklab, var(--accent) 34%, var(--glass-edge-soft));
    }
    .msg.assistant {
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 42%, transparent), transparent 64%),
        color-mix(in oklab, var(--panel-strong) 90%, transparent);
    }
    .msg.system {
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(148deg, color-mix(in oklab, rgba(255,195,120,.18) 62%, transparent), transparent 66%),
        color-mix(in oklab, var(--panel-soft) 86%, transparent);
      max-width: 100%;
    }
    .msg.user,
    .msg.assistant,
    .msg.system {
      border: 1px solid var(--glass-edge-soft);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 60%, transparent);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .msg-text-block {
      margin: 0;
      white-space: pre-wrap;
      line-height: 1.7;
    }

    .msg-text-block + .msg-text-block {
      margin-top: 8px;
    }

    .msg-code-wrap {
      margin-top: 8px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid color-mix(in oklab, var(--code-border) 92%, transparent);
      background: var(--code-bg);
    }

    .msg-code-label {
      margin: 0;
      padding: 5px 10px;
      font-size: 11px;
      line-height: 1.2;
      letter-spacing: .04em;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid color-mix(in oklab, var(--code-border) 74%, transparent);
      background: color-mix(in oklab, var(--panel-soft) 72%, var(--code-bg));
    }

    .msg-code-block {
      margin: 0;
      padding: 10px 12px;
      background: var(--code-bg);
      overflow-x: auto;
      overflow-y: hidden;
    }

    .msg-code-block code {
      display: block;
      font-family: "JetBrains Mono", "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.58;
      white-space: pre;
    }

    .msg-code-block .hljs {
      background: transparent !important;
      padding: 0;
    }

    .msg-meta { color: var(--muted); font-size: 11px; margin-top: 6px; }

    .controls {
      display: grid;
      gap: 8px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 44%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-soft) 84%, transparent);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .composer {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: end;
    }

    select,
    textarea {
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(150deg, color-mix(in oklab, var(--glass-highlight) 34%, transparent), transparent 60%),
        var(--input-bg);
      color: var(--text);
      border-radius: 10px;
      outline: 0;
      font-size: 13px;
      width: 100%;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 58%, transparent);
    }

    select { padding: 8px 10px; }
    textarea { min-height: 86px; padding: 10px; resize: none; }

    #chat-input {
      min-height: 52px;
      max-height: 180px;
      line-height: 1.58;
      border-radius: 12px;
      padding: 11px 12px;
    }

    .send-icon-btn {
      width: 42px;
      height: 42px;
      border-radius: 12px;
      border: 1px solid color-mix(in oklab, var(--accent) 42%, var(--glass-edge-soft));
      color: color-mix(in oklab, #f7fbff 88%, var(--text));
      background:
        linear-gradient(
          145deg,
          color-mix(in oklab, var(--accent) 56%, var(--panel-strong)) 0%,
          color-mix(in oklab, var(--accent-strong) 64%, var(--panel-soft)) 100%
        );
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow:
        0 10px 20px color-mix(in oklab, var(--accent) 20%, transparent),
        inset 0 1px 0 rgba(255,255,255,.24);
      transition: transform 160ms ease, filter 160ms ease, border-color 160ms ease;
      padding: 0;
    }

    .send-icon-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.04);
      border-color: color-mix(in oklab, var(--accent) 62%, var(--glass-edge-soft));
    }

    .send-icon-btn:disabled {
      opacity: .82;
      cursor: wait;
      transform: none;
      filter: none;
    }

    .send-icon-btn .send-icon {
      width: 16px;
      height: 16px;
      display: block;
      fill: none;
      stroke: currentColor;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
      transform: translateX(0.5px);
    }

    .send-icon-btn .send-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid color-mix(in oklab, white 26%, transparent);
      border-top-color: currentColor;
      border-radius: 999px;
      display: none;
      animation: spin .75s linear infinite;
    }

    .send-icon-btn.is-busy .send-icon {
      display: none;
    }

    .send-icon-btn.is-busy .send-spinner {
      display: block;
    }

    .fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 40;
      border-radius: 999px;
      padding: 12px 16px;
      font-weight: 700;
      font-size: 13px;
      display: none;
      border: 1px solid color-mix(in oklab, var(--accent) 44%, var(--glass-edge));
      background:
        linear-gradient(
          145deg,
          color-mix(in oklab, var(--accent) 54%, var(--panel-strong)),
          color-mix(in oklab, var(--accent-strong) 62%, var(--panel-soft))
        );
      backdrop-filter: blur(16px) saturate(145%);
      -webkit-backdrop-filter: blur(16px) saturate(145%);
      box-shadow: 0 12px 24px color-mix(in oklab, var(--accent) 18%, transparent), inset 0 1px 0 rgba(255,255,255,.26);
    }

    .fab.visible { display: inline-block; }

    .mobile-controls {
      display: none;
      border-bottom: 1px solid var(--glass-edge-soft);
      padding: 8px;
      justify-content: flex-start;
      background:
        linear-gradient(180deg, color-mix(in oklab, var(--glass-highlight) 20%, transparent), transparent 58%),
        color-mix(in srgb, var(--panel-soft) 74%, transparent);
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 50;
      background:
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.08), transparent 46%),
        rgba(5, 8, 14, .44);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      padding: 10px;
      display: none;
    }

    .overlay.visible { display: block; }

    .overlay-panel {
      width: min(90vw, 360px);
      height: 100%;
      border-radius: 22px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 50%, transparent), transparent 58%),
        color-mix(in oklab, var(--panel-strong) 86%, transparent);
      border: 1px solid var(--glass-edge);
      backdrop-filter: blur(20px) saturate(150%);
      -webkit-backdrop-filter: blur(20px) saturate(150%);
      box-shadow: var(--glass-shadow), inset 0 1px 0 color-mix(in oklab, var(--glass-highlight) 72%, transparent);
    }

    .icon-muted {
      color: var(--muted);
    }

    .is-hidden {
      display: none;
    }

    .overlay-actions {
      display: flex;
      justify-content: flex-end;
    }

    .overlay-scroll {
      min-height: 0;
      overflow: auto;
    }

    .chat-mobile-mount {
      height: 100%;
    }

    .empty-note,
    .muted-empty,
    .error-text {
      margin: 0;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid var(--glass-edge-soft);
      background:
        linear-gradient(148deg, color-mix(in oklab, var(--glass-highlight) 36%, transparent), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 76%, transparent);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      font-size: 13px;
    }

    .muted-empty {
      color: var(--muted);
    }

    .error-text {
      color: #b5003c;
      border-color: color-mix(in oklab, #b5003c 46%, var(--glass-edge-soft));
      background:
        linear-gradient(148deg, rgba(255, 192, 209, .22), transparent 62%),
        color-mix(in oklab, var(--panel-soft) 78%, transparent);
    }

    @media (max-width: 960px) {
      .shell { grid-template-columns: 1fr; }
      .sidebar { display: none; }
      .resizer { display: none !important; }
      .assistant { display: none; }
      .mobile-controls { display: flex; }
      .header-top { grid-template-columns: 1fr; }
      .header-spacer { display: none; }
      .header-title { font-size: 16px; }
      .header-actions { justify-content: flex-start; }
      .header-title-select { min-width: 100%; max-width: 100%; }
      .home-grid { grid-template-columns: 1fr; }
      .home-hero-top { flex-direction: column; }
      .home-orbit { display: none; }
      .home-metrics { grid-template-columns: 1fr; }
      .chapter-items { max-height: min(52vh, 460px); }
    }

    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .nav-item {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <main class="layout">
    <div class="shell" id="shell">
      <aside class="sidebar glass-strong" id="sidebar-desktop">
        <h1><a class="brand-link" id="brand-home" href="/">Noema</a></h1>
        <label class="search">
          <span class="icon-muted">⌕</span>
          <input id="sidebar-search" placeholder="教材を検索" />
        </label>
        <div id="sidebar-list"></div>
        <div class="sidebar-footer">
          <a class="button" id="login-link" href="/login">ログイン</a>
          <button class="button-ghost is-hidden" id="playground-link" type="button">プレイグラウンド</button>
          <a class="button-ghost is-hidden" id="admin-link" href="/admin.html">管理画面</a>
        </div>
      </aside>

      <section class="main glass-strong">
        <div class="mobile-controls">
          <div class="liquid-nav">
            <button class="nav-item" id="open-sidebar" type="button">教材メニュー</button>
            <button class="nav-item" id="open-chat-mobile" type="button">Assistant</button>
          </div>
        </div>

        <header class="header">
          <div class="header-top">
            <div class="header-spacer" aria-hidden="true"></div>
            <h2 class="header-title" id="header-title">読み込み中...</h2>
            <select class="header-title-select is-hidden" id="header-title-select" aria-label="ノート選択"></select>
            <div class="header-actions">
              <div class="liquid-nav">
                <a class="nav-item" id="download-btn" href="#">Download</a>
                <a class="nav-item" id="colab-btn" href="#" target="_blank" rel="noreferrer">Colabで実行</a>
                <button class="nav-item is-hidden" id="reset-playground" type="button">Reset</button>
              </div>
            </div>
          </div>
        </header>

        <div id="reader">
          <div id="selection-card" class="selection-card glass-soft">
            <div>
              <div class="selection-title">選択中のテキストを質問に添付します</div>
              <div class="selection-text" id="selection-text"></div>
            </div>
            <button class="button-ghost" id="clear-selection" type="button">解除</button>
          </div>

          <div id="reader-card" class="glass-soft">
            <article class="reader-prose" id="notebook-content">教材を読み込み中...</article>
          </div>
        </div>
      </section>

      <div class="resizer" id="chat-resizer" aria-hidden="true"></div>

      <aside class="assistant glass-strong hidden" id="assistant-panel">
        <div class="assistant-head">
          <div class="assistant-head-top">
            <h3 class="assistant-title">Assistant</h3>
            <div class="liquid-nav">
              <button class="nav-item" id="new-chat" type="button">New</button>
              <button class="nav-item" id="chat-history" type="button">History</button>
            </div>
          </div>
          <p class="assistant-subtitle">現在のノート文脈を優先して回答します。</p>
        </div>

        <div id="chat-log" class="glass-soft"></div>

        <div class="controls">
          <select id="section-select" class="is-hidden"></select>
          <div class="composer">
            <textarea id="chat-input" placeholder="ノート内容について質問する..."></textarea>
            <button class="send-icon-btn" id="send-chat" type="button" aria-label="送信" title="送信">
              <svg class="send-icon" viewBox="0 0 20 20" aria-hidden="true">
                <path d="M3.2 10L16.8 3.6 12.4 16.4 9.6 10 3.2 10Z"></path>
              </svg>
              <span class="send-spinner" aria-hidden="true"></span>
            </button>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <button class="fab button" id="chat-fab" type="button">LLMに質問</button>

  <div class="overlay" id="sidebar-overlay">
    <div class="overlay-panel glass-strong">
      <div class="overlay-actions">
        <button class="button-ghost" id="close-sidebar" type="button">閉じる</button>
      </div>
      <div id="sidebar-mobile-list" class="overlay-scroll"></div>
      <a class="button" href="/login">ログイン</a>
      <button class="button-ghost footer-link is-hidden" id="playground-link-mobile" type="button">プレイグラウンド</button>
      <a class="button-ghost footer-link is-hidden" id="admin-link-mobile" href="/admin.html">管理画面</a>
    </div>
  </div>

  <div class="overlay" id="chat-overlay">
    <div class="chat-mobile-mount" id="chat-mobile-mount"></div>
  </div>

  <script>
    (function () {
      const API_BASE = "https://52d3l83li2.execute-api.ap-northeast-3.amazonaws.com";
      const TOKEN_KEY = "noema_id_token";
      const PLAYGROUND_DRAFT_KEY_PREFIX = "noema_playground_drafts_v1";
      const PLAYGROUND_STORE_SCHEMA_VERSION = 2;
      const KEEP_LATEST_REVISIONS = 10;
      const CONFLICT_RETENTION_DAYS = 30;
      const UNREFERENCED_BASE_RETENTION_DAYS = 14;
      const KATEX_CSS_HREF = "/katex/katex.min.css";
      // MathJax v3 is Apache-2.0 licensed.
      const MATHJAX_SRC = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js";
      const ASSISTANT_MIN_WIDTH = 320;
      const ASSISTANT_MAX_WIDTH = 700;
      const ASSISTANT_CLOSE_THRESHOLD = 220;

      const state = {
        catalog: null,
        activeNotebook: null,
        openChapters: {},
        query: "",
        sectionIds: [],
        activeSection: "intro",
        selectedText: "",
        selectedSection: "",
        selectedContext: null,
        chatOpen: false,
        messages: [],
        busy: false,
        loggedIn: false,
        isAdmin: false,
        authCheckSeq: 0,
        resizing: false,
        startX: 0,
        startWidth: 400,
        playgroundEnabled: false,
        userScopeKey: "",
        activeEditorMap: new Map(),
        baseCellSourceMap: new Map(),
        playgroundSaveTimer: null,
        colabSessionBusy: false
      };

      const el = {
        sidebarList: document.getElementById("sidebar-list"),
        sidebarMobileList: document.getElementById("sidebar-mobile-list"),
        sidebarSearch: document.getElementById("sidebar-search"),
        headerTitle: document.getElementById("header-title"),
        headerTitleSelect: document.getElementById("header-title-select"),
        downloadBtn: document.getElementById("download-btn"),
        colabBtn: document.getElementById("colab-btn"),
        notebookContent: document.getElementById("notebook-content"),
        sectionSelect: document.getElementById("section-select"),
        chatLog: document.getElementById("chat-log"),
        chatInput: document.getElementById("chat-input"),
        sendChat: document.getElementById("send-chat"),
        assistantPanel: document.getElementById("assistant-panel"),
        chatFab: document.getElementById("chat-fab"),
        selectionCard: document.getElementById("selection-card"),
        selectionText: document.getElementById("selection-text"),
        clearSelection: document.getElementById("clear-selection"),
        brandHome: document.getElementById("brand-home"),
        loginLink: document.getElementById("login-link"),
        playgroundLink: document.getElementById("playground-link"),
        playgroundLinkMobile: document.getElementById("playground-link-mobile"),
        resetPlayground: document.getElementById("reset-playground"),
        adminLink: document.getElementById("admin-link"),
        adminLinkMobile: document.getElementById("admin-link-mobile"),
        newChat: document.getElementById("new-chat"),
        chatHistory: document.getElementById("chat-history"),
        sidebarOverlay: document.getElementById("sidebar-overlay"),
        chatOverlay: document.getElementById("chat-overlay"),
        openSidebar: document.getElementById("open-sidebar"),
        closeSidebar: document.getElementById("close-sidebar"),
        openChatMobile: document.getElementById("open-chat-mobile"),
        chatMobileMount: document.getElementById("chat-mobile-mount"),
        resizer: document.getElementById("chat-resizer")
      };

      let highlightPromise = null;
      let katexCssEnsurePromise = null;
      let mathJaxPromise = null;
      const preloadedNotebookPackages = new Set();
      const blockHighlightTimers = new WeakMap();

      function hasKatexCssApplied() {
        const probe = document.createElement("span");
        probe.className = "katex-mathml";
        probe.style.position = "absolute";
        probe.style.visibility = "hidden";
        probe.style.pointerEvents = "none";
        document.body.appendChild(probe);
        const style = window.getComputedStyle(probe);
        const width = parseFloat(String(style.width || "999"));
        const height = parseFloat(String(style.height || "999"));
        const hiddenByKatex = style.position === "absolute" && style.overflow === "hidden" && width <= 2 && height <= 2;
        probe.remove();
        return hiddenByKatex;
      }

      async function ensureKatexStyles() {
        if (hasKatexCssApplied()) return;
        if (!katexCssEnsurePromise) {
          katexCssEnsurePromise = fetch(`${KATEX_CSS_HREF}?v=20260218`, { cache: "no-store" })
            .then(async (response) => {
              if (!response.ok) return;
              const css = await response.text();
              if (!css.trim()) return;
              let styleTag = document.getElementById("katex-inline-fallback");
              if (!styleTag) {
                styleTag = document.createElement("style");
                styleTag.id = "katex-inline-fallback";
                document.head.appendChild(styleTag);
              }
              styleTag.textContent = css;
            })
            .catch(() => undefined)
            .finally(() => {
              katexCssEnsurePromise = null;
            });
        }
        await katexCssEnsurePromise;
      }

      function isKatexRenderingBroken(container) {
        const renderedMathml = container.querySelector(".katex .katex-mathml");
        if (!renderedMathml) return false;
        const style = window.getComputedStyle(renderedMathml);
        const width = parseFloat(String(style.width || "999"));
        const height = parseFloat(String(style.height || "999"));
        const hiddenByKatex = style.position === "absolute" && style.overflow === "hidden" && width <= 2 && height <= 2;
        return !hiddenByKatex;
      }

      function replaceKatexWithTex(container) {
        let replaced = 0;
        container.querySelectorAll(".katex").forEach((node) => {
          const annotation = node.querySelector(".katex-mathml annotation[encoding='application/x-tex']");
          const tex = annotation && annotation.textContent ? annotation.textContent.trim() : "";
          if (!tex) return;
          const displayWrapper =
            node.parentElement && node.parentElement.classList.contains("katex-display") ? node.parentElement : null;
          const texNode = document.createTextNode(displayWrapper ? `\n$$\n${tex}\n$$\n` : `$${tex}$`);
          (displayWrapper || node).replaceWith(texNode);
          replaced += 1;
        });
        return replaced > 0;
      }

      function hasTexLikeExpression(container) {
        const text = String(container.textContent || "");
        return /(\$\$[\s\S]+?\$\$|\$[^$\n]+\$|\\\([\s\S]+?\\\)|\\\[[\s\S]+?\\\])/.test(text);
      }

      async function ensureMathJax() {
        if (window.MathJax && typeof window.MathJax.typesetPromise === "function") {
          return window.MathJax;
        }
        if (!mathJaxPromise) {
          window.MathJax = window.MathJax || {
            tex: {
              inlineMath: [["$", "$"], ["\\(", "\\)"]],
              displayMath: [["$$", "$$"], ["\\[", "\\]"]]
            },
            options: {
              skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"]
            },
            svg: {
              fontCache: "global"
            }
          };

          mathJaxPromise = new Promise((resolve, reject) => {
            const script = document.createElement("script");
            script.src = MATHJAX_SRC;
            script.async = true;
            script.onload = () => resolve(window.MathJax);
            script.onerror = () => reject(new Error("MathJax load failed"));
            document.head.appendChild(script);
          });
        }
        return mathJaxPromise;
      }

      async function renderMathFallback(container) {
        if (!hasTexLikeExpression(container)) return;
        try {
          const mathJax = await ensureMathJax();
          if (mathJax && typeof mathJax.typesetPromise === "function") {
            await mathJax.typesetPromise([container]);
          }
        } catch {
          // no-op fallback
        }
      }

      function parseJwt(token) {
        try {
          const payload = token.split(".")[1];
          return JSON.parse(atob(payload.replace(/-/g, "+").replace(/_/g, "/")));
        } catch {
          return null;
        }
      }

      function getToken() {
        const token = localStorage.getItem(TOKEN_KEY) || "";
        if (!token) return "";
        const payload = parseJwt(token);
        if (!payload) return "";
        if (payload.exp && Date.now() >= payload.exp * 1000) {
          localStorage.removeItem(TOKEN_KEY);
          return "";
        }
        return token;
      }

      function resolveUserScopeKey(token) {
        const payload = parseJwt(token);
        if (!payload || typeof payload !== "object") return "";
        const raw =
          (typeof payload.sub === "string" && payload.sub.trim()) ||
          (typeof payload.email === "string" && payload.email.trim()) ||
          "";
        return raw ? raw.toLowerCase() : "";
      }

      function getPlaygroundStorageKey() {
        if (!state.userScopeKey) return "";
        return `${PLAYGROUND_DRAFT_KEY_PREFIX}:${state.userScopeKey}`;
      }

      function createEmptyPlaygroundStore() {
        return {
          schemaVersion: PLAYGROUND_STORE_SCHEMA_VERSION,
          notebooks: {},
          bases: {},
          conflicts: []
        };
      }

      function toValidIsoString(raw, fallbackIso) {
        const text = String(raw || "").trim();
        if (!text) return fallbackIso;
        const time = Date.parse(text);
        if (Number.isNaN(time)) return fallbackIso;
        return new Date(time).toISOString();
      }

      function toEpochMillis(isoString, fallbackMs) {
        const ms = Date.parse(String(isoString || ""));
        if (!Number.isNaN(ms)) return ms;
        if (Number.isFinite(Number(fallbackMs))) return Number(fallbackMs);
        return Date.now();
      }

      function normalizeCellArray(cells) {
        if (!Array.isArray(cells)) return [];
        return cells.map((cell) => String(cell));
      }

      function hashFNV1a(text) {
        let hash = 2166136261;
        for (let i = 0; i < text.length; i += 1) {
          hash ^= text.charCodeAt(i);
          hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
        }
        return (hash >>> 0).toString(16).padStart(8, "0");
      }

      function makeBaseId(cells) {
        const normalized = normalizeCellArray(cells);
        const signature = normalized.join("\u241E");
        return `base:${hashFNV1a(signature)}:${normalized.length}`;
      }

      function makeRevisionId() {
        const randomPart = Math.random().toString(36).slice(2, 10);
        return `rev:${Date.now().toString(36)}:${randomPart}`;
      }

      function sameCells(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i += 1) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }

      function ensureBaseSnapshot(store, cells, createdAtIso) {
        const normalizedCells = normalizeCellArray(cells);
        const baseId = makeBaseId(normalizedCells);
        if (!store.bases[baseId]) {
          store.bases[baseId] = {
            cells: normalizedCells,
            createdAt: createdAtIso
          };
        }
        return baseId;
      }

      function latestCellsFromEntry(store, entry) {
        if (!entry || !Array.isArray(entry.revisions) || entry.revisions.length === 0) return [];
        const latest = entry.revisions[entry.revisions.length - 1];
        if (!latest || !latest.baseId) return [];
        const base = store.bases[latest.baseId];
        if (!base) return [];
        return normalizeCellArray(base.cells);
      }

      function prunePlaygroundStore(store) {
        const nowMs = Date.now();
        const conflictRetentionMs = CONFLICT_RETENTION_DAYS * 24 * 60 * 60 * 1000;
        const unreferencedBaseRetentionMs = UNREFERENCED_BASE_RETENTION_DAYS * 24 * 60 * 60 * 1000;

        Object.keys(store.notebooks).forEach((notebookId) => {
          const entry = store.notebooks[notebookId];
          if (!entry || !Array.isArray(entry.revisions)) {
            delete store.notebooks[notebookId];
            return;
          }
          entry.revisions.sort((a, b) => toEpochMillis(a.createdAt, nowMs) - toEpochMillis(b.createdAt, nowMs));
          if (entry.revisions.length > KEEP_LATEST_REVISIONS) {
            entry.revisions = entry.revisions.slice(-KEEP_LATEST_REVISIONS);
          }
          if (entry.revisions.length === 0) {
            delete store.notebooks[notebookId];
          }
        });

        const keptConflicts = [];
        if (Array.isArray(store.conflicts)) {
          store.conflicts.forEach((conflict) => {
            const createdAtMs = toEpochMillis(conflict.createdAt, nowMs);
            if (!createdAtMs || nowMs - createdAtMs > conflictRetentionMs) return;
            keptConflicts.push(conflict);
          });
        }
        store.conflicts = keptConflicts;

        const referencedBaseIds = new Set();
        Object.values(store.notebooks).forEach((entry) => {
          if (!entry || !Array.isArray(entry.revisions)) return;
          entry.revisions.forEach((revision) => {
            if (revision && typeof revision.baseId === "string" && revision.baseId) {
              referencedBaseIds.add(revision.baseId);
            }
          });
        });
        store.conflicts.forEach((conflict) => {
          if (conflict && typeof conflict.baseId === "string" && conflict.baseId) {
            referencedBaseIds.add(conflict.baseId);
          }
        });

        Object.keys(store.bases).forEach((baseId) => {
          if (referencedBaseIds.has(baseId)) return;
          const base = store.bases[baseId];
          const createdAtMs = toEpochMillis(base && base.createdAt, nowMs);
          if (!createdAtMs || nowMs - createdAtMs > unreferencedBaseRetentionMs) {
            delete store.bases[baseId];
          }
        });

        return store;
      }

      function normalizePlaygroundStore(rawStore) {
        const fallbackIso = new Date().toISOString();
        const normalized = createEmptyPlaygroundStore();
        const parsed = rawStore && typeof rawStore === "object" ? rawStore : {};

        if (parsed.schemaVersion === PLAYGROUND_STORE_SCHEMA_VERSION) {
          const bases = parsed.bases && typeof parsed.bases === "object" ? parsed.bases : {};
          Object.entries(bases).forEach(([baseId, baseValue]) => {
            if (!baseId) return;
            const record = baseValue && typeof baseValue === "object" ? baseValue : {};
            const cells = normalizeCellArray(record.cells);
            normalized.bases[baseId] = {
              cells,
              createdAt: toValidIsoString(record.createdAt, fallbackIso)
            };
          });

          const notebooks = parsed.notebooks && typeof parsed.notebooks === "object" ? parsed.notebooks : {};
          Object.entries(notebooks).forEach(([notebookId, notebookValue]) => {
            if (!notebookId) return;
            const record = notebookValue && typeof notebookValue === "object" ? notebookValue : {};
            const revisions = Array.isArray(record.revisions) ? record.revisions : [];
            const normalizedRevisions = revisions
              .map((revision) => {
                const item = revision && typeof revision === "object" ? revision : {};
                const baseId = String(item.baseId || "").trim();
                if (!baseId || !normalized.bases[baseId]) return null;
                return {
                  id: String(item.id || makeRevisionId()),
                  baseId,
                  createdAt: toValidIsoString(item.createdAt, fallbackIso)
                };
              })
              .filter(Boolean);
            if (normalizedRevisions.length) {
              normalized.notebooks[notebookId] = {
                revisions: normalizedRevisions
              };
            }
          });

          normalized.conflicts = Array.isArray(parsed.conflicts)
            ? parsed.conflicts
                .map((conflict) => {
                  const item = conflict && typeof conflict === "object" ? conflict : {};
                  const notebookId = String(item.notebookId || "").trim();
                  if (!notebookId) return null;
                  const baseId = String(item.baseId || "").trim();
                  return {
                    id: String(item.id || `conflict:${makeRevisionId()}`),
                    notebookId,
                    baseId: baseId || undefined,
                    reason: String(item.reason || "unknown"),
                    createdAt: toValidIsoString(item.createdAt, fallbackIso)
                  };
                })
                .filter(Boolean)
            : [];
          return prunePlaygroundStore(normalized);
        }

        Object.entries(parsed).forEach(([notebookId, notebookValue]) => {
          if (!notebookId || notebookId === "schemaVersion" || notebookId === "notebooks" || notebookId === "bases" || notebookId === "conflicts") {
            return;
          }
          const record = notebookValue && typeof notebookValue === "object" ? notebookValue : {};
          const cells = normalizeCellArray(record.cells);
          const createdAt = toValidIsoString(record.updatedAt, fallbackIso);
          const baseId = ensureBaseSnapshot(normalized, cells, createdAt);
          normalized.notebooks[notebookId] = {
            revisions: [
              {
                id: makeRevisionId(),
                baseId,
                createdAt
              }
            ]
          };
        });

        return prunePlaygroundStore(normalized);
      }

      function readPlaygroundStore() {
        const key = getPlaygroundStorageKey();
        if (!key) return createEmptyPlaygroundStore();
        const serialized = localStorage.getItem(key) || "";
        let parsed = {};
        try {
          parsed = serialized ? JSON.parse(serialized) : {};
        } catch {}
        const normalized = normalizePlaygroundStore(parsed);
        try {
          const normalizedSerialized = JSON.stringify(normalized);
          if (serialized !== normalizedSerialized) {
            localStorage.setItem(key, normalizedSerialized);
          }
        } catch {}
        return normalized;
      }

      function writePlaygroundStore(nextStore) {
        const key = getPlaygroundStorageKey();
        if (!key) return;
        try {
          const normalized = normalizePlaygroundStore(nextStore);
          localStorage.setItem(key, JSON.stringify(normalized));
        } catch {}
      }

      function collectBaseCellSources() {
        return Array.from(state.baseCellSourceMap.keys())
          .sort((a, b) => a - b)
          .map((index) => String(state.baseCellSourceMap.get(index) || ""));
      }

      function mergeDraftOntoBase(baseCells, draftCells) {
        const normalizedBase = normalizeCellArray(baseCells);
        const normalizedDraft = normalizeCellArray(draftCells);
        const maxLength = Math.max(normalizedBase.length, normalizedDraft.length);
        const merged = normalizedBase.slice();
        let hasChanges = false;

        for (let index = 0; index < maxLength; index += 1) {
          if (index >= normalizedDraft.length) continue;
          const baseSource = index < normalizedBase.length ? normalizedBase[index] : "";
          const draftSource = normalizedDraft[index];
          if (draftSource !== baseSource) {
            hasChanges = true;
            merged[index] = draftSource;
          }
        }

        return { merged, hasChanges };
      }

      function readNotebookPlaygroundDraft(notebookId, baseCells = []) {
        if (!notebookId) return [];
        const store = readPlaygroundStore();
        const entry = store.notebooks[notebookId];
        const latestDraftCells = latestCellsFromEntry(store, entry);
        const normalizedBase = normalizeCellArray(baseCells);
        if (!normalizedBase.length) return latestDraftCells;

        const { merged, hasChanges } = mergeDraftOntoBase(normalizedBase, latestDraftCells);
        if (hasChanges) return merged;

        if (store.notebooks[notebookId]) {
          delete store.notebooks[notebookId];
          writePlaygroundStore(store);
        }
        return [];
      }

      function writeNotebookPlaygroundDraft(notebookId, cells, baseCells = []) {
        if (!notebookId) return;
        const normalized = normalizeCellArray(cells);
        const normalizedBase = normalizeCellArray(baseCells);
        const store = readPlaygroundStore();
        const entry = store.notebooks[notebookId] || { revisions: [] };
        const latestCells = latestCellsFromEntry(store, entry);

        if (normalizedBase.length && sameCells(normalized, normalizedBase)) {
          if (store.notebooks[notebookId]) {
            delete store.notebooks[notebookId];
            writePlaygroundStore(store);
          }
          return;
        }
        if (sameCells(latestCells, normalized)) return;

        const createdAt = new Date().toISOString();
        const baseId = ensureBaseSnapshot(store, normalized, createdAt);
        entry.revisions = Array.isArray(entry.revisions) ? entry.revisions : [];
        entry.revisions.push({
          id: makeRevisionId(),
          baseId,
          createdAt
        });
        store.notebooks[notebookId] = entry;
        writePlaygroundStore(store);
      }

      function clearNotebookPlaygroundDraft(notebookId) {
        if (!notebookId) return;
        const store = readPlaygroundStore();
        if (!(notebookId in store.notebooks)) return;
        delete store.notebooks[notebookId];
        writePlaygroundStore(store);
      }

      function collectEditableCellSources() {
        return Array.from(state.activeEditorMap.keys())
          .sort((a, b) => a - b)
          .map((index) => {
            const editor = state.activeEditorMap.get(index);
            return editor ? String(editor.value || "") : "";
          });
      }

      function schedulePlaygroundAutosave() {
        if (!state.loggedIn || !state.playgroundEnabled || !state.activeNotebook) return;
        if (state.playgroundSaveTimer) {
          clearTimeout(state.playgroundSaveTimer);
        }
        state.playgroundSaveTimer = setTimeout(() => {
          state.playgroundSaveTimer = null;
          if (!state.activeNotebook) return;
          writeNotebookPlaygroundDraft(
            state.activeNotebook.id,
            collectEditableCellSources(),
            collectBaseCellSources()
          );
        }, 320);
      }

      function applyEditorSourcesForCurrentMode() {
        if (!state.activeEditorMap.size) return;
        const notebookId = state.activeNotebook ? state.activeNotebook.id : "";
        const drafts =
          state.playgroundEnabled && notebookId
            ? readNotebookPlaygroundDraft(notebookId, collectBaseCellSources())
            : [];

        Array.from(state.activeEditorMap.entries()).forEach(([index, editor]) => {
          const baseSource = state.baseCellSourceMap.get(index) ?? normalizeRunnableSource(editor.value || "");
          const draftSource =
            drafts[index] !== undefined ? normalizeRunnableSource(drafts[index]) : baseSource;
          const source = state.playgroundEnabled ? draftSource : baseSource;

          editor.value = source;
          autosizeCodeEditor(editor);

          const code = el.notebookContent.querySelector(`pre[data-noema-cell-index="${index}"] > code`);
          if (code) {
            code.textContent = source;
          }

          const wrapper = code && code.closest ? code.closest(".code-runner") : null;
          const runButton = wrapper ? wrapper.querySelector(".run-code") : null;
          if (runButton) {
            runButton.classList.remove("is-done", "is-failed", "is-running");
          }
        });
      }

      function applyPlaygroundModeToCurrentNotebook() {
        const wrappers = el.notebookContent.querySelectorAll(".code-runner");
        wrappers.forEach((wrapper) => {
          wrapper.classList.toggle("playground-active", state.playgroundEnabled);
        });
        if (state.playgroundEnabled) {
          Array.from(state.activeEditorMap.values()).forEach((editor) => {
            autosizeCodeEditor(editor);
          });
        }
      }

      function renderPlaygroundHeaderControls() {
        const showControls = state.loggedIn && state.playgroundEnabled && !!state.activeNotebook;
        el.headerTitle.classList.toggle("is-hidden", showControls);
        el.headerTitleSelect.classList.toggle("is-hidden", !showControls);
        el.resetPlayground.classList.toggle("is-hidden", !showControls);
        el.headerTitleSelect.disabled = !showControls;
      }

      function setElementVisibility(target, visible) {
        if (!target) return;
        target.classList.toggle("is-hidden", !visible);
        target.hidden = !visible;
        target.setAttribute("aria-hidden", visible ? "false" : "true");
      }

      function hidePrivilegedSidebarControls() {
        setElementVisibility(el.playgroundLink, false);
        setElementVisibility(el.playgroundLinkMobile, false);
        setElementVisibility(el.adminLink, false);
        setElementVisibility(el.adminLinkMobile, false);
      }

      function renderPlaygroundSidebarControls() {
        const visible = state.loggedIn;
        setElementVisibility(el.playgroundLink, visible);
        setElementVisibility(el.playgroundLinkMobile, visible);
        const label = state.playgroundEnabled ? "プレイグラウンド終了" : "プレイグラウンド";
        el.playgroundLink.textContent = label;
        el.playgroundLinkMobile.textContent = label;
      }

      function populateHeaderNotebookSelect() {
        const chapters = notebookList();
        const options = [];
        chapters.forEach((chapter) => {
          chapter.notebooks.forEach((notebook) => {
            options.push(
              `<option value="${notebook.id}">${escapeHtml(`${chapter.title} / ${notebook.title}`)}</option>`
            );
          });
        });
        el.headerTitleSelect.innerHTML = options.join("");
        if (state.activeNotebook) {
          el.headerTitleSelect.value = state.activeNotebook.id;
        }
      }

      async function setPlaygroundEnabled(nextEnabled) {
        if (nextEnabled && !state.loggedIn) {
          window.location.href = "/login";
          return;
        }
        state.playgroundEnabled = Boolean(nextEnabled);
        applyEditorSourcesForCurrentMode();
        renderPlaygroundSidebarControls();
        renderPlaygroundHeaderControls();
        applyPlaygroundModeToCurrentNotebook();
        await applySyntaxHighlight(el.notebookContent);
      }

      async function updateAdminVisibility(token) {
        const seq = ++state.authCheckSeq;
        state.isAdmin = false;
        setElementVisibility(el.adminLink, false);
        setElementVisibility(el.adminLinkMobile, false);

        try {
          const response = await fetch(`${API_BASE}/api/me`, {
            headers: { Authorization: `Bearer ${token}` }
          });
          if (!response.ok) return;

          const payload = await response.json();
          if (seq !== state.authCheckSeq) return;

          state.isAdmin = Boolean(payload && payload.isAdmin);
          if (state.isAdmin) {
            setElementVisibility(el.adminLink, true);
            setElementVisibility(el.adminLinkMobile, true);
          }
        } catch {
          // keep hidden when check fails
        }
      }

      function updateAuthState() {
        hidePrivilegedSidebarControls();
        const token = getToken();
        state.loggedIn = Boolean(token);
        state.userScopeKey = token ? resolveUserScopeKey(token) : "";

        if (state.loggedIn) {
          el.loginLink.textContent = "ログアウト";
          el.loginLink.href = "#";
          el.loginLink.onclick = function (event) {
            event.preventDefault();
            localStorage.removeItem(TOKEN_KEY);
            updateAuthState();
            showHomeDashboard();
          };
          el.chatFab.classList.add("visible");
          void updateAdminVisibility(token);
          if (state.activeNotebook) {
            void preloadNotebookPackages(el.notebookContent, state.activeNotebook.id);
          }
          renderPlaygroundSidebarControls();
          renderPlaygroundHeaderControls();
          return;
        }

        state.authCheckSeq += 1;
        state.isAdmin = false;
        state.chatOpen = false;
        state.playgroundEnabled = false;
        applyEditorSourcesForCurrentMode();
        applyPlaygroundModeToCurrentNotebook();
        el.assistantPanel.classList.add("hidden");
        el.resizer.classList.remove("visible");
        el.chatFab.classList.remove("visible");
        setElementVisibility(el.adminLink, false);
        setElementVisibility(el.adminLinkMobile, false);
        preloadedNotebookPackages.clear();
        state.activeEditorMap = new Map();
        state.baseCellSourceMap = new Map();
        if (state.playgroundSaveTimer) {
          clearTimeout(state.playgroundSaveTimer);
          state.playgroundSaveTimer = null;
        }

        el.loginLink.textContent = "ログイン";
        el.loginLink.href = "/login";
        el.loginLink.onclick = null;
        renderPlaygroundSidebarControls();
        renderPlaygroundHeaderControls();
      }

      function notebookList() {
        const chapters = state.catalog?.chapters || [];
        return chapters
          .slice()
          .sort((a, b) => a.order - b.order)
          .map((chapter) => ({
            ...chapter,
            notebooks: chapter.notebooks.slice().sort((a, b) => a.order - b.order)
          }));
      }

      function matchNotebook(notebook, query) {
        if (!query) return true;
        const hay = `${notebook.title} ${notebook.id} ${(notebook.tags || []).join(" ")}`.toLowerCase();
        return hay.includes(query);
      }

      function buildSidebarHtml(forMobile) {
        const query = state.query.trim().toLowerCase();
        const chapters = notebookList()
          .map((chapter) => ({ ...chapter, notebooks: chapter.notebooks.filter((nb) => matchNotebook(nb, query)) }))
          .filter((chapter) => chapter.notebooks.length > 0);

        if (chapters.length === 0) {
          return '<p class="muted-empty">一致する教材がありません。</p>';
        }

        return chapters
          .map((chapter) => {
            const expanded = Boolean(state.openChapters[chapter.id]);
            const items = expanded
              ? `<div class="chapter-items">${chapter.notebooks
                  .map((nb) => {
                    const active = state.activeNotebook && state.activeNotebook.id === nb.id ? "active" : "";
                    return `<button class="nb-item ${active}" data-nb-id="${nb.id}" data-mobile="${forMobile ? "1" : "0"}">${nb.title}</button>`;
                  })
                  .join("")}</div>`
              : "";

            return `
              <section class="chapter glass-soft">
                <button class="chapter-toggle" data-chapter-id="${chapter.id}" data-mobile="${forMobile ? "1" : "0"}" type="button" aria-expanded="${expanded ? "true" : "false"}">
                  <span class="chapter-title">${chapter.title}</span>
                  <span class="chapter-arrow ${expanded ? "expanded" : ""}" aria-hidden="true">
                    <svg viewBox="0 0 12 12" focusable="false">
                      <path d="M4 2.25 L7.75 6 L4 9.75"></path>
                    </svg>
                  </span>
                </button>
                ${items}
              </section>
            `;
          })
          .join("");
      }

      function bindSidebar(container) {
        Array.from(container.querySelectorAll(".chapter-toggle")).forEach((button) => {
          button.addEventListener("click", function () {
            const id = button.getAttribute("data-chapter-id") || "";
            state.openChapters[id] = !state.openChapters[id];
            renderSidebar();
          });
        });

        Array.from(container.querySelectorAll(".nb-item")).forEach((button) => {
          button.addEventListener("click", function () {
            const id = button.getAttribute("data-nb-id") || "";
            if (id) {
              selectNotebook(id);
            }
            el.sidebarOverlay.classList.remove("visible");
          });
        });
      }

      function renderSidebar() {
        el.sidebarList.innerHTML = buildSidebarHtml(false);
        el.sidebarMobileList.innerHTML = buildSidebarHtml(true);
        bindSidebar(el.sidebarList);
        bindSidebar(el.sidebarMobileList);
      }

      function extractArticle(htmlText) {
        const doc = new DOMParser().parseFromString(htmlText, "text/html");
        const article = doc.querySelector("article") || doc.querySelector("main") || doc.body;
        return article ? article.innerHTML : htmlText;
      }

      function extractSectionIds(container) {
        const ids = [];
        container.querySelectorAll("h1[id], h2[id], h3[id], section[id], article[id]").forEach((node) => {
          if (node.id) ids.push(node.id);
        });
        return Array.from(new Set(ids));
      }

      function renderSections() {
        if (!state.activeNotebook) {
          el.sectionSelect.innerHTML = '<option value="intro">intro</option>';
          el.sectionSelect.value = "intro";
          el.sectionSelect.disabled = true;
          return;
        }

        const ids = state.sectionIds.length ? state.sectionIds : ["intro"];
        el.sectionSelect.innerHTML = ids.map((id) => `<option value="${id}">${id}</option>`).join("");
        if (!ids.includes(state.activeSection)) {
          state.activeSection = ids[0];
        }
        el.sectionSelect.value = state.activeSection;
        el.sectionSelect.disabled = false;
      }

      function renderHeader() {
        const nb = state.activeNotebook;
        if (!nb) {
          el.headerTitle.textContent = "教材トップ";
          el.downloadBtn.style.display = "none";
          el.colabBtn.style.display = "none";
          renderPlaygroundHeaderControls();
          return;
        }

        el.downloadBtn.style.display = "";
        el.colabBtn.style.display = "";
        el.headerTitle.textContent = nb.title;
        el.downloadBtn.href = `/notebooks/${nb.id}.ipynb`;
        el.downloadBtn.setAttribute("download", `${nb.id}.ipynb`);
        el.colabBtn.href = nb.colabUrl || "#";
        populateHeaderNotebookSelect();
        renderPlaygroundHeaderControls();
      }

      function renderHomeDashboard() {
        const chapters = notebookList();
        const notebooks = chapters.flatMap((chapter) => chapter.notebooks);
        const chapterCount = chapters.length;
        const notebookCount = notebooks.length;
        const firstNotebookId = notebooks[0]?.id || "";
        const assistantStateLabel = state.loggedIn ? "有効" : "ログインで有効化";

        el.notebookContent.innerHTML = `
          <section class="home-stage">
            <section class="home-hero-shell glass-soft">
              <div class="home-hero-top">
                <div>
                  <p class="home-kicker">Noema Learning Hub</p>
                  <h3 class="home-title">教材トップ</h3>
                  <p class="home-lead">機械学習・LLM・強化学習を、ノートを実行しながら段階的に学べます。サイドバーから教材を選び、詰まったら Assistant にそのまま質問してください。</p>
                </div>
                <div class="home-orbit" aria-hidden="true"><span></span><span></span><span></span></div>
              </div>
              <div class="home-metrics">
                <article class="home-metric">
                  <span class="home-metric-label">Sections</span>
                  <span class="home-metric-value">${chapterCount}</span>
                </article>
                <article class="home-metric">
                  <span class="home-metric-label">Notebooks</span>
                  <span class="home-metric-value">${notebookCount}</span>
                </article>
                <article class="home-metric">
                  <span class="home-metric-label">Assistant</span>
                  <span class="home-metric-value home-metric-value-status">${assistantStateLabel}</span>
                </article>
              </div>
              <div class="home-cta-row">
                <button class="button home-cta" type="button" data-home-action="start" ${firstNotebookId ? "" : "disabled"}>最初の教材を開く</button>
                <button class="button-ghost home-cta-ghost" type="button" data-home-action="assistant">${state.loggedIn ? "Assistantを開く" : "ログインして質問する"}</button>
              </div>
            </section>
            <section class="home-grid">
              <article class="home-card glass-soft">
                <div class="home-card-head"><span class="home-card-icon">01</span><strong>読むだけで終わらない</strong></div>
                <p>教材本文のコードはページ内で実行できます。値を変えて挙動を観察し、概念をその場で検証できます。</p>
              </article>
              <article class="home-card glass-soft">
                <div class="home-card-head"><span class="home-card-icon">02</span><strong>文脈付きで質問</strong></div>
                <p>本文を選択して質問すると、その選択箇所を文脈に含めて回答します。曖昧な質問でも意図が伝わりやすくなります。</p>
              </article>
              <article class="home-card glass-soft">
                <div class="home-card-head"><span class="home-card-icon">03</span><strong>Colab で再現</strong></div>
                <p>ヘッダーの Colab ボタンから外部実行環境へ遷移可能。ローカル依存なしで再現性の高い確認ができます。</p>
              </article>
              <article class="home-card glass-soft">
                <div class="home-card-head"><span class="home-card-icon">04</span><strong>管理と学習を分離</strong></div>
                <p>教材閲覧は軽く、管理作業は管理画面へ集約。学習導線を崩さずにコンテンツ更新を継続できます。</p>
              </article>
            </section>
          </section>
        `;

        const startButton = el.notebookContent.querySelector('[data-home-action="start"]');
        if (startButton) {
          startButton.addEventListener("click", function () {
            if (firstNotebookId) {
              void selectNotebook(firstNotebookId);
            }
          });
        }

        const assistantButton = el.notebookContent.querySelector('[data-home-action="assistant"]');
        if (assistantButton) {
          assistantButton.addEventListener("click", function () {
            if (!state.loggedIn) {
              window.location.href = "/login";
              return;
            }
            setChatOpen(true);
          });
        }
      }

      function extractImportedModulesFromSource(source) {
        const modules = new Set();
        const normalized = normalizeRunnableSource(source || "");
        const lines = normalized.split(/\r?\n/);

        lines.forEach((line) => {
          const trimmed = line.replace(/#.*/, "").trim();
          if (!trimmed) return;

          const importMatch = trimmed.match(/^import\s+(.+)$/);
          if (importMatch && importMatch[1]) {
            importMatch[1]
              .split(",")
              .map((part) => part.trim())
              .forEach((part) => {
                if (!part) return;
                const moduleName = part.split(/\s+as\s+/i)[0].trim().split(".")[0];
                if (moduleName) modules.add(moduleName);
              });
            return;
          }

          const fromMatch = trimmed.match(/^from\s+([A-Za-z0-9_.]+)\s+import\s+/);
          if (fromMatch && fromMatch[1]) {
            const moduleName = fromMatch[1].split(".")[0];
            if (moduleName) modules.add(moduleName);
          }
        });

        return Array.from(modules);
      }

      function collectNotebookImportedModules(container) {
        const modules = new Set();
        container.querySelectorAll("pre > code").forEach((code) => {
          extractImportedModulesFromSource(code.textContent || "").forEach((moduleName) => {
            modules.add(moduleName);
          });
        });
        return Array.from(modules);
      }

      function normalizeModuleHints(moduleNames) {
        const hints = new Set();
        moduleNames.forEach((moduleName) => {
          const normalized = (moduleName || "").split(".")[0].trim();
          if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(normalized)) return;
          hints.add(normalized);
        });
        return Array.from(hints).slice(0, 24);
      }

      async function preloadNotebookPackages(container, notebookId) {
        if (!state.loggedIn) return;
        const token = getToken();
        if (!token) return;

        const modules = normalizeModuleHints(collectNotebookImportedModules(container));
        const preloadKey = `${notebookId}:${modules.join(",")}`;
        if (preloadedNotebookPackages.has(preloadKey)) return;

        preloadedNotebookPackages.add(preloadKey);
        try {
          await fetch(`${API_BASE}/api/runtime/python/preload`, {
            method: "POST",
            headers: {
              "content-type": "application/json",
              Authorization: `Bearer ${token}`
            },
            body: JSON.stringify({
              notebookId,
              expectedModules: modules
            })
          });
        } catch (error) {
          preloadedNotebookPackages.delete(preloadKey);
          console.warn("Runtime preload failed", notebookId, error);
        }
      }

      async function runPythonOnServer(source, notebookId, sectionId, expectedModules) {
        const token = getToken();
        if (!token) {
          throw new Error("コード実行にはログインが必要です。");
        }

        const response = await fetch(`${API_BASE}/api/runtime/python`, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            Authorization: `Bearer ${token}`
          },
          body: JSON.stringify({
            notebookId,
            sectionId,
            code: source,
            expectedModules: normalizeModuleHints(expectedModules)
          })
        });

        let payload = {};
        try {
          payload = await response.json();
        } catch {
          payload = {};
        }

        if (!response.ok) {
          const errorText = payload && typeof payload.error === "string" ? payload.error : "Python実行に失敗しました。";
          throw new Error(errorText);
        }

        return payload;
      }

      function renderPythonRunOutput(payload) {
        const stdout = payload && typeof payload.stdout === "string" ? payload.stdout.trim() : "";
        const stderr = payload && typeof payload.stderr === "string" ? payload.stderr.trim() : "";
        const errorText = payload && typeof payload.error === "string" ? payload.error.trim() : "";
        const durationMs = payload && Number.isFinite(Number(payload.durationMs)) ? Number(payload.durationMs) : 0;
        const installedPackages = Array.isArray(payload?.installedPackages)
          ? payload.installedPackages.map((pkg) => String(pkg).trim()).filter(Boolean)
          : [];

        const lines = [];
        if (stdout) lines.push(stdout);
        if (stderr) lines.push(stderr);
        if (errorText) lines.push(`Error: ${errorText}`);
        if (installedPackages.length) lines.push(`[installed] ${installedPackages.join(", ")}`);
        lines.push(`[runtime] AWS Python ${durationMs}ms`);
        return lines.join("\n") || "(no output)";
      }

      function ensureHighlightLibrary() {
        if (window.hljs) return Promise.resolve(window.hljs);
        if (!highlightPromise) {
          highlightPromise = new Promise((resolve, reject) => {
            const script = document.createElement("script");
            script.src = "/highlight/highlight.min.js";
            script.async = true;
            script.onload = () => resolve(window.hljs);
            script.onerror = () => reject(new Error("Highlight.js load failed"));
            document.head.appendChild(script);
          });
        }
        return highlightPromise;
      }

      async function applySyntaxHighlight(container) {
        const blocks = container.querySelectorAll("pre > code");
        if (!blocks.length) return;
        try {
          const hljs = await ensureHighlightLibrary();
          if (!hljs) return;
          blocks.forEach((block) => {
            if (!block.className.includes("language-")) {
              block.classList.add("language-python");
            }
            if (block.dataset && block.dataset.highlighted) {
              delete block.dataset.highlighted;
            }
            block.classList.remove("hljs");
            hljs.highlightElement(block);
          });
        } catch {}
      }

      async function applySyntaxHighlightToBlock(block) {
        try {
          const hljs = await ensureHighlightLibrary();
          if (!hljs) return;
          if (!block.className.includes("language-")) {
            block.classList.add("language-python");
          }
          if (block.dataset && block.dataset.highlighted) {
            delete block.dataset.highlighted;
          }
          block.classList.remove("hljs");
          hljs.highlightElement(block);
        } catch {}
      }

      function queueHighlightForBlock(block) {
        if (!block) return;
        const currentTimer = blockHighlightTimers.get(block);
        if (currentTimer) {
          clearTimeout(currentTimer);
        }
        const nextTimer = setTimeout(() => {
          blockHighlightTimers.delete(block);
          void applySyntaxHighlightToBlock(block);
        }, 90);
        blockHighlightTimers.set(block, nextTimer);
      }

      function autosizeCodeEditor(editor) {
        if (!editor) return;
        editor.style.height = "0px";
        editor.style.height = `${Math.max(editor.scrollHeight, 80)}px`;
      }

      function normalizeRunnableSource(rawSource) {
        if (!rawSource) return "";
        // nbconvertの出力によっては改行が "\n" の2文字で入るため、実行前に正規化する。
        if (!rawSource.includes("\n") && /\\[nrt]/.test(rawSource)) {
          return rawSource
            .replace(/\\r/g, "\r")
            .replace(/\\n/g, "\n")
            .replace(/\\t/g, "\t");
        }
        return rawSource;
      }

      function textToSourceLines(text) {
        if (!text) return [];
        const lines = String(text).split("\n");
        return lines.map((line, index) => (index < lines.length - 1 ? `${line}\n` : line));
      }

      function applyEditedSourcesToIpynb(ipynb, editedSources) {
        const notebook = ipynb && typeof ipynb === "object" ? ipynb : null;
        const cells = notebook && Array.isArray(notebook.cells) ? notebook.cells : null;
        if (!cells) {
          throw new Error("Invalid ipynb format");
        }

        let codeCellIndex = 0;
        cells.forEach((cell) => {
          if (!cell || typeof cell !== "object" || cell.cell_type !== "code") return;
          const nextSource = editedSources[codeCellIndex];
          if (nextSource !== undefined) {
            const normalized = normalizeRunnableSource(String(nextSource));
            if (Array.isArray(cell.source)) {
              cell.source = textToSourceLines(normalized);
            } else {
              cell.source = normalized;
            }
          }
          codeCellIndex += 1;
        });
      }

      function openInNewTab(url) {
        window.open(url, "_blank", "noopener,noreferrer");
      }

      function navigateTab(tabRef, url) {
        if (tabRef && typeof tabRef.location !== "undefined") {
          tabRef.location.assign(url);
          return;
        }
        openInNewTab(url);
      }

      async function openColabWithPlaygroundDraft() {
        if (!state.activeNotebook || state.colabSessionBusy) return;
        const notebookId = state.activeNotebook.id;
        const fallbackColabUrl = state.activeNotebook.colabUrl || "https://colab.research.google.com/";
        const token = getToken();
        if (!token) {
          openInNewTab(fallbackColabUrl);
          return;
        }

        const editedSources = collectEditableCellSources().map((source) => normalizeRunnableSource(source));
        if (!editedSources.length) {
          openInNewTab(fallbackColabUrl);
          return;
        }

        const pendingTab = window.open("about:blank", "_blank", "noopener,noreferrer");
        state.colabSessionBusy = true;
        const originalLabel = el.colabBtn.textContent || "Colabで実行";
        el.colabBtn.textContent = "Colab 準備中...";
        el.colabBtn.setAttribute("aria-disabled", "true");

        try {
          const ipynbResponse = await fetch(`/notebooks/${encodeURIComponent(notebookId)}.ipynb`, { cache: "no-cache" });
          if (!ipynbResponse.ok) {
            throw new Error("ノートブックの取得に失敗しました。");
          }
          const ipynbRaw = await ipynbResponse.text();
          const notebookJson = JSON.parse(ipynbRaw);
          applyEditedSourcesToIpynb(notebookJson, editedSources);

          const sessionResponse = await fetch(
            `${API_BASE}/api/notebooks/${encodeURIComponent(notebookId)}/colab-session`,
            {
              method: "POST",
              headers: {
                "content-type": "application/json",
                Authorization: `Bearer ${token}`
              },
              body: JSON.stringify({
                ipynbRaw: `${JSON.stringify(notebookJson, null, 2)}\n`
              })
            }
          );

          let payload = {};
          try {
            payload = await sessionResponse.json();
          } catch {
            payload = {};
          }

          if (!sessionResponse.ok) {
            const message =
              payload && typeof payload.error === "string"
                ? payload.error
                : "Colab 用ノートの作成に失敗しました。";
            throw new Error(message);
          }

          const notebookPath =
            payload && typeof payload.notebookPath === "string" ? payload.notebookPath.trim() : "";
          if (!notebookPath.startsWith("/")) {
            throw new Error("Colab 用ノートのURLが不正です。");
          }

          const notebookUrl = `${window.location.origin}${notebookPath}`;
          const colabUrl = `https://colab.research.google.com/?url=${encodeURIComponent(notebookUrl)}`;
          navigateTab(pendingTab, colabUrl);
        } catch (error) {
          console.warn("Open Colab with playground draft failed", error);
          navigateTab(pendingTab, fallbackColabUrl);
        } finally {
          state.colabSessionBusy = false;
          el.colabBtn.textContent = originalLabel;
          el.colabBtn.removeAttribute("aria-disabled");
        }
      }

      const EXECUTION_CONTEXT_CHAR_LIMIT = 19000;

      function getCellSource(codeBlock, index) {
        const editor = state.activeEditorMap.get(index);
        if (editor) {
          return normalizeRunnableSource(editor.value || "");
        }
        return normalizeRunnableSource(codeBlock.textContent || "");
      }

      function buildExecutionContext(codeBlocks, uptoIndex) {
        const parts = [];
        const modules = new Set();
        let totalChars = 0;

        for (let i = uptoIndex; i >= 0; i -= 1) {
          const source = getCellSource(codeBlocks[i], i);
          if (!source.trim()) continue;

          const chunk = `# --- cell ${i + 1} ---\n${source.trimEnd()}\n`;
          if (parts.length > 0 && totalChars + chunk.length > EXECUTION_CONTEXT_CHAR_LIMIT) {
            break;
          }

          parts.unshift(chunk);
          totalChars += chunk.length;
          extractImportedModulesFromSource(source).forEach((moduleName) => modules.add(moduleName));
        }

        return {
          source: parts.join("\n"),
          expectedModules: Array.from(modules)
        };
      }

      function enhanceCodeBlocks() {
        const blocks = Array.from(el.notebookContent.querySelectorAll("pre > code"));
        const notebookId = state.activeNotebook ? state.activeNotebook.id : "";
        const defaultSources = blocks.map((code) => normalizeRunnableSource(code.textContent || ""));
        const savedDraft = notebookId ? readNotebookPlaygroundDraft(notebookId, defaultSources) : [];
        state.activeEditorMap = new Map();
        state.baseCellSourceMap = new Map();

        blocks.forEach((code, codeIndex) => {
          const pre = code.parentElement;
          if (!pre || pre.dataset.noemaRunnable === "1") return;
          pre.dataset.noemaRunnable = "1";
          pre.dataset.noemaCellIndex = String(codeIndex);
          let clearExecutionStatus = () => {};
          const defaultSource = defaultSources[codeIndex] || normalizeRunnableSource(code.textContent || "");
          state.baseCellSourceMap.set(codeIndex, defaultSource);
          const restoredSource =
            state.playgroundEnabled && savedDraft[codeIndex] !== undefined
              ? normalizeRunnableSource(savedDraft[codeIndex])
              : defaultSource;
          code.textContent = restoredSource;

          const wrapper = document.createElement("div");
          wrapper.className = "code-runner";
          pre.parentNode.insertBefore(wrapper, pre);
          const shell = document.createElement("div");
          shell.className = "code-runner-shell";
          wrapper.appendChild(shell);

          const rail = document.createElement("div");
          rail.className = "code-runner-rail";
          shell.appendChild(rail);

          const editorSurface = document.createElement("div");
          editorSurface.className = "code-editor-surface";
          shell.appendChild(editorSurface);
          editorSurface.appendChild(pre);

          const editor = document.createElement("textarea");
          editor.className = "code-editor";
          editor.setAttribute("aria-label", `Editable code cell ${codeIndex + 1}`);
          editor.value = restoredSource;
          editor.addEventListener("input", () => {
            autosizeCodeEditor(editor);
            code.textContent = normalizeRunnableSource(editor.value || "");
            clearExecutionStatus();
            queueHighlightForBlock(code);
            schedulePlaygroundAutosave();
          });
          editor.addEventListener("keydown", (event) => {
            if (event.key !== "Tab") return;
            event.preventDefault();
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const next = `${editor.value.slice(0, start)}  ${editor.value.slice(end)}`;
            editor.value = next;
            editor.selectionStart = editor.selectionEnd = start + 2;
            autosizeCodeEditor(editor);
            code.textContent = normalizeRunnableSource(editor.value || "");
            clearExecutionStatus();
            queueHighlightForBlock(code);
            schedulePlaygroundAutosave();
          });
          autosizeCodeEditor(editor);
          state.activeEditorMap.set(codeIndex, editor);
          editorSurface.appendChild(editor);

          const button = document.createElement("button");
          button.className = "run-code";
          button.type = "button";
          button.setAttribute("aria-label", "Run code");
          button.setAttribute("title", "Run");
          button.innerHTML =
            '<svg class="run-icon" viewBox="0 0 12 12" aria-hidden="true"><path d="M3 2.2L10 6 3 9.8V2.2Z"></path></svg>' +
            '<svg class="run-done-icon" viewBox="0 0 12 12" aria-hidden="true"><path d="M2 6.2L4.7 9 10 3"></path></svg>' +
            '<svg class="run-fail-icon" viewBox="0 0 12 12" aria-hidden="true"><path d="M3 3L9 9M9 3L3 9"></path></svg>' +
            '<span class="run-spinner" aria-hidden="true"></span>';
          clearExecutionStatus = () => {
            button.classList.remove("is-done", "is-failed");
          };
          rail.appendChild(button);

          const output = document.createElement("pre");
          output.className = "code-output";
          wrapper.appendChild(output);

          button.addEventListener("click", async () => {
            const context = buildExecutionContext(blocks, codeIndex);
            const source = context.source;
            if (!source.trim()) return;

            button.disabled = true;
            button.classList.remove("is-done", "is-failed");
            button.classList.add("is-running");
            output.classList.add("visible");
            output.textContent = "AWS Python runtime executing...";

            try {
              const payload = await runPythonOnServer(
                source,
                (state.activeNotebook && state.activeNotebook.id) || "unknown-notebook",
                state.activeSection || "intro",
                context.expectedModules
              );
              output.textContent = renderPythonRunOutput(payload);
              const runtimeFailed = Boolean(payload && typeof payload.error === "string" && payload.error.trim());
              if (runtimeFailed) {
                button.classList.add("is-failed");
              } else {
                button.classList.add("is-done");
              }
            } catch (error) {
              output.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
              button.classList.add("is-failed");
            } finally {
              button.disabled = false;
              button.classList.remove("is-running");
            }
          });
        });

        applyPlaygroundModeToCurrentNotebook();
      }

      async function selectNotebook(notebookId) {
        if (state.playgroundSaveTimer) {
          clearTimeout(state.playgroundSaveTimer);
          state.playgroundSaveTimer = null;
        }
        if (state.playgroundEnabled && state.activeNotebook && state.activeEditorMap.size) {
          writeNotebookPlaygroundDraft(
            state.activeNotebook.id,
            collectEditableCellSources(),
            collectBaseCellSources()
          );
        }

        const chapters = notebookList();
        let target = null;
        let chapterId = "";

        for (const chapter of chapters) {
          const found = chapter.notebooks.find((nb) => nb.id === notebookId);
          if (found) {
            target = found;
            chapterId = chapter.id;
            break;
          }
        }

        if (!target) return;

        state.activeNotebook = target;
        if (chapterId) {
          state.openChapters[chapterId] = true;
        }
        state.selectedText = "";
        state.selectedSection = "";
        state.selectedContext = null;
        state.sectionIds = ["intro"];

        renderSidebar();
        renderHeader();
        renderSelectionCard();
        el.notebookContent.innerHTML = "教材を読み込み中...";

        try {
          const response = await fetch(target.htmlPath, { cache: "no-cache" });
          if (!response.ok) throw new Error("教材HTMLの読み込みに失敗しました");
          const htmlText = await response.text();
          el.notebookContent.innerHTML = extractArticle(htmlText);
          el.notebookContent.classList.add("reader-prose");
          await ensureKatexStyles();
          const katexBroken = isKatexRenderingBroken(el.notebookContent);
          if (katexBroken) {
            const convertedFromBrokenKatex = replaceKatexWithTex(el.notebookContent);
            if (convertedFromBrokenKatex) {
              await renderMathFallback(el.notebookContent);
            }
          } else if (!hasKatexCssApplied()) {
            const convertedFromBrokenKatex = replaceKatexWithTex(el.notebookContent);
            if (convertedFromBrokenKatex) {
              await renderMathFallback(el.notebookContent);
            }
          }
          state.sectionIds = extractSectionIds(el.notebookContent);
          state.activeSection = state.sectionIds[0] || "intro";
          renderHeader();
          renderSections();
          void preloadNotebookPackages(el.notebookContent, target.id);
          enhanceCodeBlocks();
          await applySyntaxHighlight(el.notebookContent);

          const url = new URL(window.location.href);
          url.searchParams.set("notebookId", target.id);
          window.history.replaceState(null, "", url.toString());
        } catch (error) {
          const msg = error instanceof Error ? error.message : "読み込みエラー";
          el.notebookContent.innerHTML = `<p class=\"error-text\">${msg}</p>`;
        }
      }

      function captureSelection() {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return null;

        const text = selection.toString().trim();
        if (!text) return null;

        const range = selection.getRangeAt(0);
        if (!el.notebookContent.contains(range.startContainer) || !el.notebookContent.contains(range.endContainer)) {
          return null;
        }

        const findCodeNode = (node) => {
          let current = node && node.nodeType === Node.ELEMENT_NODE ? node : node && node.parentElement;
          while (current && current !== el.notebookContent) {
            if (current.tagName === "CODE" && current.parentElement && current.parentElement.tagName === "PRE") {
              return current;
            }
            current = current.parentElement;
          }
          return null;
        };

        const startCodeNode = findCodeNode(range.startContainer);
        const endCodeNode = findCodeNode(range.endContainer);
        const isSameCodeBlock = startCodeNode && endCodeNode && startCodeNode === endCodeNode;

        let node = range.startContainer.nodeType === Node.ELEMENT_NODE ? range.startContainer : range.startContainer.parentElement;
        let sectionId = "";
        while (node && node !== el.notebookContent) {
          if (node.id) {
            sectionId = node.id;
            break;
          }
          node = node.parentElement;
        }

        if (isSameCodeBlock) {
          const pre = startCodeNode.parentElement;
          const rawIndex = pre?.dataset?.noemaCellIndex;
          const cellIndex = Number.isFinite(Number(rawIndex)) ? Number(rawIndex) : -1;
          const currentCode = cellIndex >= 0 && state.activeEditorMap.get(cellIndex)
            ? String(state.activeEditorMap.get(cellIndex).value || "")
            : String(startCodeNode.textContent || "");

          const codeText = normalizeRunnableSource(currentCode);
          const segmentRange = document.createRange();
          segmentRange.setStart(startCodeNode, 0);
          segmentRange.setEnd(range.startContainer, range.startOffset);
          const beforeTextLength = segmentRange.toString().length;
          const selectedLength = range.toString().length;
          const startOffset = Math.max(0, Math.min(beforeTextLength, codeText.length));
          const endOffset = Math.max(startOffset, Math.min(startOffset + selectedLength, codeText.length));

          const before = codeText.slice(0, startOffset);
          const selected = codeText.slice(startOffset, endOffset) || text;
          const lineStart = before.split(/\r?\n/).length;
          const lineEnd = (before + selected).split(/\r?\n/).length;
          const lines = codeText.split(/\r?\n/);
          const contextStart = Math.max(1, lineStart - 3);
          const contextEnd = Math.min(lines.length, lineEnd + 3);
          const contextSnippet = lines.slice(contextStart - 1, contextEnd).join("\n");

          return {
            text: selected || text,
            sectionId: sectionId || `code-cell-${Math.max(cellIndex, 0)}`,
            selectionType: "code",
            codeCellIndex: cellIndex,
            lineStart,
            lineEnd,
            contextSnippet
          };
        }

        return { text, sectionId, selectionType: "text" };
      }

      function buildQuestionTextWithSelection(questionText, selection) {
        if (!selection || !selection.text) return questionText;
        if (selection.selectionType !== "code") {
          return `${questionText}\n\n[Selection]\n${selection.text}`;
        }

        const notebookId = state.activeNotebook ? state.activeNotebook.id : "unknown-notebook";
        const cellLabel =
          Number.isFinite(selection.codeCellIndex) && selection.codeCellIndex >= 0
            ? String(selection.codeCellIndex + 1)
            : "unknown";
        const lineLabel =
          Number.isFinite(selection.lineStart) && Number.isFinite(selection.lineEnd)
            ? `${selection.lineStart}-${selection.lineEnd}`
            : "unknown";
        const context = String(selection.contextSnippet || "").trim();
        const contextBlock = context
          ? `\n\n[CodeContext]\n\`\`\`python\n${context}\n\`\`\``
          : "";

        return `${questionText}\n\n[SelectionType]\ncode\n[NotebookId]\n${notebookId}\n[CodeCell]\n${cellLabel}\n[SelectedLines]\n${lineLabel}\n[SelectedCode]\n\`\`\`python\n${selection.text}\n\`\`\`${contextBlock}`;
      }

      function renderSelectionCard() {
        if (!state.selectedText) {
          el.selectionCard.style.display = "none";
          el.selectionText.textContent = "";
          return;
        }

        el.selectionCard.style.display = "flex";
        if (state.selectedContext && state.selectedContext.selectionType === "code") {
          const cell =
            Number.isFinite(state.selectedContext.codeCellIndex) && state.selectedContext.codeCellIndex >= 0
              ? state.selectedContext.codeCellIndex + 1
              : "?";
          const lineStart = Number.isFinite(state.selectedContext.lineStart) ? state.selectedContext.lineStart : "?";
          const lineEnd = Number.isFinite(state.selectedContext.lineEnd) ? state.selectedContext.lineEnd : "?";
          el.selectionText.textContent = `[code cell ${cell}, lines ${lineStart}-${lineEnd}] ${state.selectedText}`;
          return;
        }
        el.selectionText.textContent = state.selectedText;
      }

      function pushMessage(role, text, meta) {
        state.messages.push({ role, text, meta: meta || {} });
        renderMessages();
      }

      function renderMessages() {
        if (!state.messages.length) {
          el.chatLog.innerHTML = '<p class="muted-empty">質問を入力して送信してください。</p>';
          return;
        }

        el.chatLog.innerHTML = state.messages
          .map((message) => {
            const refsText = message.meta && message.meta.refs ? String(message.meta.refs) : "";
            const refs = refsText ? `<div class=\"msg-meta\">参照: ${escapeHtml(refsText)}</div>` : "";
            const avatar = message.role === "assistant" ? "AI" : message.role === "user" ? "You" : "";
            const body =
              message.role === "assistant"
                ? renderAssistantMessageContent(message.text)
                : `<p class=\"msg-text-block\">${escapeHtmlWithLineBreaks(message.text)}</p>`;
            return `
              <div class=\"msg-wrap ${message.role}\">
                <span class=\"msg-avatar\" aria-hidden=\"true\">${avatar}</span>
                <article class=\"msg ${message.role}\">${body}${refs}</article>
              </div>
            `;
          })
          .join("");
        void applyChatSyntaxHighlight();
        el.chatLog.scrollTop = el.chatLog.scrollHeight;
      }

      function escapeHtml(value) {
        return value
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function escapeHtmlWithLineBreaks(value) {
        return escapeHtml(value).replace(/\n/g, "<br>");
      }

      function normalizeCodeLanguage(raw) {
        const value = String(raw || "").trim().toLowerCase();
        if (!value) return "plaintext";
        if (!/^[a-z0-9_+#.-]{1,24}$/.test(value)) return "plaintext";
        return value;
      }

      function splitAssistantMessageSegments(text) {
        const source = String(text || "");
        const segments = [];
        const fence = /```([A-Za-z0-9_+#.-]*)?[ \t]*\n?([\s\S]*?)```/g;
        let cursor = 0;
        let match;

        while ((match = fence.exec(source)) !== null) {
          if (match.index > cursor) {
            segments.push({ type: "text", text: source.slice(cursor, match.index) });
          }
          segments.push({
            type: "code",
            language: normalizeCodeLanguage(match[1] || ""),
            text: String(match[2] || "").replace(/\n+$/, "")
          });
          cursor = fence.lastIndex;
        }

        if (cursor < source.length) {
          segments.push({ type: "text", text: source.slice(cursor) });
        }
        return segments.length ? segments : [{ type: "text", text: source }];
      }

      function renderAssistantMessageContent(text) {
        const segments = splitAssistantMessageSegments(text);
        const html = segments
          .map((segment) => {
            if (segment.type === "code") {
              const language = normalizeCodeLanguage(segment.language);
              const label = language === "plaintext" ? "code" : language;
              return `
                <div class="msg-code-wrap">
                  <div class="msg-code-label">${escapeHtml(label)}</div>
                  <pre class="msg-code-block"><code class="language-${escapeHtml(language)}">${escapeHtml(segment.text)}</code></pre>
                </div>
              `;
            }

            if (!String(segment.text || "").trim()) return "";
            return `<p class="msg-text-block">${escapeHtmlWithLineBreaks(String(segment.text).trim())}</p>`;
          })
          .join("");

        if (html) return html;
        return `<p class="msg-text-block">${escapeHtmlWithLineBreaks(String(text || ""))}</p>`;
      }

      async function applyChatSyntaxHighlight() {
        const blocks = el.chatLog.querySelectorAll(".msg-code-block > code");
        if (!blocks.length) return;
        try {
          const hljs = await ensureHighlightLibrary();
          if (!hljs) return;
          blocks.forEach((block) => {
            if (block.dataset && block.dataset.highlighted) {
              delete block.dataset.highlighted;
            }
            block.classList.remove("hljs");
            hljs.highlightElement(block);
          });
        } catch {}
      }

      async function pollAnswer(questionId, token) {
        for (let i = 0; i < 25; i += 1) {
          const response = await fetch(`${API_BASE}/api/questions/${encodeURIComponent(questionId)}/answer`, {
            headers: { Authorization: `Bearer ${token}` }
          });

          if (response.status === 202) {
            await new Promise((resolve) => setTimeout(resolve, 1200));
            continue;
          }

          if (!response.ok) {
            let error = "回答の取得に失敗しました";
            try {
              const payload = await response.json();
              if (payload && payload.error) error = payload.error;
            } catch {}
            throw new Error(error);
          }

          return response.json();
        }

        throw new Error("回答待機がタイムアウトしました");
      }

      async function sendQuestion() {
        if (state.busy || !state.loggedIn) return;

        const text = el.chatInput.value.trim();
        if (!text) return;

        const notebook = state.activeNotebook;
        if (!notebook) {
          pushMessage("system", "先にサイドバーから教材を選択してください。");
          return;
        }

        const token = getToken();
        if (!token) {
          pushMessage("system", "セッションが切れています。再ログインしてください。");
          setChatOpen(false);
          updateAuthState();
          return;
        }

        const selection = captureSelection();
        if (selection) {
          state.selectedContext = selection;
          state.selectedText = selection.text;
          state.selectedSection = selection.sectionId || "";
          renderSelectionCard();
        }

        const sectionId = state.selectedSection || state.activeSection || "intro";
        const questionText = buildQuestionTextWithSelection(text, state.selectedContext);

        pushMessage("user", text);
        el.chatInput.value = "";
        state.busy = true;
        el.sendChat.disabled = true;
        el.sendChat.classList.add("is-busy");
        el.sendChat.setAttribute("aria-label", "送信中");
        el.sendChat.setAttribute("title", "送信中");

        try {
          const response = await fetch(`${API_BASE}/api/questions`, {
            method: "POST",
            headers: {
              "content-type": "application/json",
              Authorization: `Bearer ${token}`
            },
            body: JSON.stringify({
              notebookId: notebook.id,
              sectionId,
              questionText
            })
          });

          if (!response.ok) {
            let error = "質問の送信に失敗しました";
            try {
              const payload = await response.json();
              if (payload && payload.error) error = payload.error;
            } catch {}
            throw new Error(error);
          }

          const payload = await response.json();
          const answer = await pollAnswer(payload.questionId, token);
          const refs = (answer.sourceReferences || []).map((source) => `${source.notebookId}${source.location}`).join(", ");
          pushMessage("assistant", answer.answerText || "回答が空でした", { refs });
        } catch (error) {
          pushMessage("system", error instanceof Error ? error.message : "質問処理に失敗しました");
        } finally {
          state.busy = false;
          el.sendChat.disabled = false;
          el.sendChat.classList.remove("is-busy");
          el.sendChat.setAttribute("aria-label", "送信");
          el.sendChat.setAttribute("title", "送信");
        }
      }

      async function loadQuestionHistory() {
        if (!state.loggedIn) {
          window.location.href = "/login";
          return;
        }

        const notebook = state.activeNotebook;
        if (!notebook) {
          pushMessage("system", "先にサイドバーから教材を選択してください。");
          return;
        }

        const token = getToken();
        if (!token) {
          pushMessage("system", "セッションが切れています。再ログインしてください。");
          setChatOpen(false);
          updateAuthState();
          return;
        }

        el.chatHistory.disabled = true;
        const before = el.chatHistory.textContent;
        el.chatHistory.textContent = "Loading...";

        try {
          const response = await fetch(
            `${API_BASE}/api/questions/history?notebookId=${encodeURIComponent(notebook.id)}`,
            { headers: { Authorization: `Bearer ${token}` } }
          );

          if (!response.ok) {
            let error = "履歴の取得に失敗しました";
            try {
              const payload = await response.json();
              if (payload && payload.error) error = payload.error;
            } catch {}
            throw new Error(error);
          }

          const payload = await response.json();
          const items = Array.isArray(payload?.items) ? payload.items : [];

          if (!items.length) {
            state.messages = [ { role: "system", text: "このノートの履歴はまだありません。", meta: {} } ];
            renderMessages();
            return;
          }

          const sorted = items
            .slice()
            .sort((a, b) => String(a.createdAt || "").localeCompare(String(b.createdAt || "")));

          state.messages = [];
          sorted.forEach((item) => {
            if (item.questionText) {
              state.messages.push({ role: "user", text: String(item.questionText), meta: {} });
            }
            if (item.answerText) {
              const refs = Array.isArray(item.sourceReferences)
                ? item.sourceReferences.map((source) => `${source.notebookId || ""}${source.location || ""}`).join(", ")
                : "";
              state.messages.push({ role: "assistant", text: String(item.answerText), meta: refs ? { refs } : {} });
            }
          });
          renderMessages();
        } catch (error) {
          pushMessage("system", error instanceof Error ? error.message : "履歴の取得に失敗しました");
        } finally {
          el.chatHistory.disabled = false;
          el.chatHistory.textContent = before || "History";
        }
      }

      function setChatOpen(open) {
        if (open && !state.loggedIn) {
          window.location.href = "/login";
          return;
        }

        state.chatOpen = open;
        el.assistantPanel.classList.toggle("hidden", !open);
        el.resizer.classList.toggle("visible", open && window.innerWidth > 960);
        el.chatFab.classList.toggle("visible", !open && state.loggedIn);
      }

      function startResize(event) {
        if (window.innerWidth <= 960 || !state.chatOpen) return;
        state.resizing = true;
        state.startX = event.clientX;
        state.startWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--assistant-width")) || 400;
        document.body.style.userSelect = "none";
      }

      function onResize(event) {
        if (!state.resizing) return;
        const diff = state.startX - event.clientX;
        const rawWidth = state.startWidth + diff;
        if (rawWidth <= ASSISTANT_CLOSE_THRESHOLD) {
          document.documentElement.style.setProperty("--assistant-width", `${ASSISTANT_MIN_WIDTH}px`);
          setChatOpen(false);
          stopResize();
          return;
        }
        const next = Math.max(ASSISTANT_MIN_WIDTH, Math.min(ASSISTANT_MAX_WIDTH, rawWidth));
        document.documentElement.style.setProperty("--assistant-width", `${next}px`);
      }

      function stopResize() {
        if (!state.resizing) return;
        state.resizing = false;
        document.body.style.userSelect = "";
      }

      async function loadCatalog() {
        const apiResponse = await fetch(`${API_BASE}/api/catalog`, { cache: "no-cache" }).catch(() => null);
        if (apiResponse && apiResponse.ok) {
          return apiResponse.json();
        }

        const response = await fetch("/catalog.json", { cache: "no-cache" });
        if (!response.ok) {
          throw new Error("catalog の読み込みに失敗しました");
        }
        return response.json();
      }

      function findInitialNotebookId() {
        const q = new URLSearchParams(window.location.search);
        return q.get("notebookId") || "";
      }

      function showHomeDashboard() {
        state.activeNotebook = null;
        state.sectionIds = [];
        state.activeSection = "intro";
        state.selectedText = "";
        state.selectedSection = "";
        state.selectedContext = null;
        state.activeEditorMap = new Map();
        renderSidebar();
        renderHeader();
        renderSections();
        renderSelectionCard();
        renderHomeDashboard();
        const url = new URL(window.location.href);
        url.searchParams.delete("notebookId");
        window.history.replaceState(null, "", url.toString());
      }

      async function init() {
        updateAuthState();
        renderMessages();

        try {
          state.catalog = await loadCatalog();
        } catch (error) {
          el.notebookContent.innerHTML = `<p class=\"error-text\">${error instanceof Error ? error.message : "初期化エラー"}</p>`;
          return;
        }

        const chapters = notebookList();
        const notebooks = chapters.flatMap((chapter) => chapter.notebooks);
        if (!notebooks.length) {
          el.notebookContent.innerHTML = '<p class="empty-note">教材がありません。</p>';
          return;
        }

        const requested = findInitialNotebookId();
        const requestedNotebook = notebooks.find((nb) => nb.id === requested) || null;

        state.openChapters = {};
        renderSidebar();
        if (requestedNotebook) {
          await selectNotebook(requestedNotebook.id);
        } else {
          showHomeDashboard();
        }
      }

      el.sidebarSearch.addEventListener("input", function (event) {
        state.query = event.target.value || "";
        renderSidebar();
      });

      el.brandHome.addEventListener("click", function (event) {
        event.preventDefault();
        showHomeDashboard();
      });

      el.playgroundLink.addEventListener("click", function () {
        void (async () => {
          if (!state.loggedIn) {
            window.location.href = "/login";
            return;
          }
          const nextEnabled = !state.playgroundEnabled;
          await setPlaygroundEnabled(nextEnabled);
          if (nextEnabled && !state.activeNotebook) {
            const firstNotebook = notebookList().flatMap((chapter) => chapter.notebooks)[0];
            if (firstNotebook) {
              await selectNotebook(firstNotebook.id);
            }
          }
        })();
      });

      el.playgroundLinkMobile.addEventListener("click", function () {
        void (async () => {
          el.sidebarOverlay.classList.remove("visible");
          if (!state.loggedIn) {
            window.location.href = "/login";
            return;
          }
          const nextEnabled = !state.playgroundEnabled;
          await setPlaygroundEnabled(nextEnabled);
          if (nextEnabled && !state.activeNotebook) {
            const firstNotebook = notebookList().flatMap((chapter) => chapter.notebooks)[0];
            if (firstNotebook) {
              await selectNotebook(firstNotebook.id);
            }
          }
        })();
      });

      el.headerTitleSelect.addEventListener("change", function () {
        const notebookId = String(el.headerTitleSelect.value || "").trim();
        if (!notebookId || (state.activeNotebook && state.activeNotebook.id === notebookId)) return;
        void selectNotebook(notebookId);
      });

      el.resetPlayground.addEventListener("click", function () {
        if (!state.activeNotebook) return;
        const shouldReset = window.confirm("プレイグラウンドの編集内容を破棄して初期状態へ戻しますか？");
        if (!shouldReset) return;

        clearNotebookPlaygroundDraft(state.activeNotebook.id);
        void selectNotebook(state.activeNotebook.id);
      });

      el.sectionSelect.addEventListener("change", function () {
        state.activeSection = el.sectionSelect.value;
      });

      el.colabBtn.addEventListener("click", function (event) {
        if (!state.activeNotebook) return;
        if (!state.loggedIn || !state.playgroundEnabled || !state.activeEditorMap.size) return;
        event.preventDefault();
        void openColabWithPlaygroundDraft();
      });

      el.sendChat.addEventListener("click", function () {
        void sendQuestion();
      });

      el.chatInput.addEventListener("keydown", function (event) {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          event.preventDefault();
          void sendQuestion();
        }
      });

      el.clearSelection.addEventListener("click", function () {
        state.selectedText = "";
        state.selectedSection = "";
        state.selectedContext = null;
        renderSelectionCard();
      });

      el.newChat.addEventListener("click", function () {
        state.messages = [];
        renderMessages();
      });

      el.chatHistory.addEventListener("click", function () {
        void loadQuestionHistory();
      });

      el.chatFab.addEventListener("click", function () {
        setChatOpen(true);
      });

      el.openSidebar.addEventListener("click", function () {
        el.sidebarOverlay.classList.add("visible");
      });

      el.closeSidebar.addEventListener("click", function () {
        el.sidebarOverlay.classList.remove("visible");
      });

      el.openChatMobile.addEventListener("click", function () {
        if (!state.loggedIn) {
          window.location.href = "/login";
          return;
        }
        setChatOpen(true);
        el.chatOverlay.classList.add("visible");
        el.chatMobileMount.innerHTML = "";
        el.chatMobileMount.appendChild(el.assistantPanel);
        el.assistantPanel.style.display = "flex";
      });

      el.sidebarOverlay.addEventListener("click", function (event) {
        if (event.target === el.sidebarOverlay) {
          el.sidebarOverlay.classList.remove("visible");
        }
      });

      el.chatOverlay.addEventListener("click", function (event) {
        if (event.target === el.chatOverlay) {
          el.chatOverlay.classList.remove("visible");
          if (window.innerWidth <= 960) {
            document.getElementById("shell").appendChild(el.assistantPanel);
          }
        }
      });

      el.resizer.addEventListener("mousedown", startResize);
      window.addEventListener("mousemove", onResize);
      window.addEventListener("mouseup", stopResize);
      window.addEventListener("mouseleave", stopResize);

      window.addEventListener("resize", function () {
        if (window.innerWidth <= 960) {
          el.resizer.classList.remove("visible");
        } else if (state.chatOpen) {
          el.resizer.classList.add("visible");
          if (el.assistantPanel.parentElement !== document.getElementById("shell")) {
            document.getElementById("shell").appendChild(el.assistantPanel);
          }
          el.chatOverlay.classList.remove("visible");
        }
      });

      void init();
    })();
  </script>
</body>
</html>
